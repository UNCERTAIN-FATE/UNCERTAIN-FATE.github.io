<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数字图像处理与应用</title>
    <link href="/2024/03/24/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <url>/2024/03/24/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="数字图像处理与应用"><a href="#数字图像处理与应用" class="headerlink" title="数字图像处理与应用"></a>数字图像处理与应用</h1><h2 id="第一讲-数字图像与数字图像处理概述（学什么，有什么用）"><a href="#第一讲-数字图像与数字图像处理概述（学什么，有什么用）" class="headerlink" title="第一讲 数字图像与数字图像处理概述（学什么，有什么用）"></a>第一讲 数字图像与数字图像处理概述（学什么，有什么用）</h2><h3 id="1-1-数字图像与数字图像处理（是什么）"><a href="#1-1-数字图像与数字图像处理（是什么）" class="headerlink" title="1.1 数字图像与数字图像处理（是什么）"></a>1.1 数字图像与数字图像处理（是什么）</h3><h4 id="图："><a href="#图：" class="headerlink" title="图："></a>图：</h4><p>是物体反射或者透射电磁波的分布。</p><h4 id="像："><a href="#像：" class="headerlink" title="像："></a>像：</h4><p>是人的视觉系统对接收的图信息在大脑中形成的印象。</p><h4 id="图像："><a href="#图像：" class="headerlink" title="图像："></a>图像：</h4><p>是“图”和“像”的结合。<br>具体来说，就是用各种观测系统以不同形式和手段观测客观世界而获得的、可以直接或间接作用于人的视觉系统而产生的视知觉实体。</p><h4 id="图像处理："><a href="#图像处理：" class="headerlink" title="图像处理："></a>图像处理：</h4><p>是对图像信息进行加工以满足人的视觉或应用需求的行为。<br>处理方法通常有：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1.</span>模拟图像处理：它是利用光学透镜或光学照相方法对模拟图像进行的处理，其实时性强、速度快、处理信息量大、分辨率高，但是处理精度差，难有判断功能<br><span class="hljs-number">2.</span>数字图像处理<br><span class="hljs-number">3.</span>光电结合处理：用光学方法完成运算量巨大的处理<span class="hljs-comment">(如频谱变换等)</span>，而用计算机对光学处理结果<span class="hljs-comment">(如频谱)</span>进行分析判断等处理。该方法是前两种方法的有机给音，它集结了二者的优点。<br></code></pre></td></tr></table></figure><h4 id="数字图像处理"><a href="#数字图像处理" class="headerlink" title="数字图像处理:"></a>数字图像处理:</h4><p>就是利用计算机技术或其他数字技术，对图像信息进行某些数学运算和各种加工处理，以改善图像的视觉效果和提高图像实用性的技术。<br>流程：图像一—&gt;图像处理系统—&gt;图像二</p><h5 id="数字图像处理的优点"><a href="#数字图像处理的优点" class="headerlink" title="数字图像处理的优点"></a>数字图像处理的优点</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.精度高：对于一幅图像而言，数字化时不管是用<span class="hljs-number">4</span>比特、<span class="hljs-number">8</span>比特还是其它比特表示，只需改变计算机中程序的参数，处理方法不变。所以从原理上讲不管对多高精度的数字图像进行处理都是可能的。而在模拟图像处理中，要想使精度提高一个数量级，就必须对装置进行大幅度改进。<br><span class="hljs-attribute">2</span>.再现性好：不管是什么数字图像，均用数组或数组集合表示。在传送和复制图像时，只在计算机内部进行处理，这样数据就不会丢失或遭破坏，保持了完好的再现性。而在模拟图像处理过程中，就会因为各种干扰因素而无法保持图像的再现性。<br><span class="hljs-attribute">3</span>.通用性、灵活性强：对可见图像和不可见光图像(如x光图像、热红外图像和超声波图像等)，尽管这些图像生成所用设备规模和精度各不相同，但当把这些图像数字化后对于计算机来说，都可同样进行处理，这就是数字处理图像的通用性。另外，改变处理图像的计算机程序，可对图像进行各种各样的处理，如上下滚动、漫游、拼接、合成、变换、放大、缩小和各种逻捐运算等，所以灵活性很高。<br></code></pre></td></tr></table></figure><h4 id="图像分析："><a href="#图像分析：" class="headerlink" title="图像分析："></a>图像分析：</h4><p>通过对图像中不同对象进行分割来对图像中目标进行分类和识别的技术</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">1</span><span class="hljs-string">.</span><span class="hljs-comment">图像分析是比图像处理更高一级的计算处理过程。(高级)</span><br><span class="hljs-comment">2</span><span class="hljs-string">.</span><span class="hljs-comment">图像分析的目的：分类。是缩减对图像的描述，以使其更适合于计算机处理及对不同目标的分类。</span><br><span class="hljs-comment">3</span><span class="hljs-string">.</span><span class="hljs-comment">图像分析的基本特征：输入是图像，输出是对输入图像进行描述的信息。</span><br><span class="hljs-comment">流程：图像</span><span class="hljs-literal">---</span>&gt;<span class="hljs-comment">图像分析系统</span><span class="hljs-literal">---</span>&gt;<span class="hljs-comment">对图像进行描述的信息</span><br></code></pre></td></tr></table></figure><h5 id="图像处理与图像分析的关系"><a href="#图像处理与图像分析的关系" class="headerlink" title="图像处理与图像分析的关系"></a>图像处理与图像分析的关系</h5><p><img src="/pic/71.png" alt="img"></p><h3 id="1-2-数字图像处理系统组成及研究内容（后面上课的概述）"><a href="#1-2-数字图像处理系统组成及研究内容（后面上课的概述）" class="headerlink" title="1.2 数字图像处理系统组成及研究内容（后面上课的概述）"></a>1.2 数字图像处理系统组成及研究内容（后面上课的概述）</h3><h4 id="基本图像处理系统的结构"><a href="#基本图像处理系统的结构" class="headerlink" title="基本图像处理系统的结构"></a>基本图像处理系统的结构</h4><p><img src="/pic/72.png" alt="img"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">输入设备一般为相机、扫描仪等<br>处理设备和储存设备一般为手机、电脑等<br>输出设备一般为打印机、印刷机等<br></code></pre></td></tr></table></figure><h4 id="图像处理技术研究的内容"><a href="#图像处理技术研究的内容" class="headerlink" title="图像处理技术研究的内容"></a>图像处理技术研究的内容</h4><h5 id="图像变换"><a href="#图像变换" class="headerlink" title="图像变换"></a>图像变换</h5><p>是简化图像处理过程和提高图像处理效果的基本技术，最典型的图像变换主要有傅里叶变换、离散余弦变换和小波变换等。</p><h5 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h5><p>是或简单地突出图像中感兴趣的特征，或想方法显现图像中那些模糊了的细节，以使图像更清晰地被显示或更适合于人或机器的处理与分析的一种技术。</p><h5 id="图像恢复"><a href="#图像恢复" class="headerlink" title="图像恢复"></a>图像恢复</h5><p>是一种从图像退化的数学或概率模型出发，研究改进图像外观，从而使恢复以后的图像尽可能地反映原始图像的本来面目的一种技术，其目的是获得与景物真实面貌相像的图像。</p><h5 id="图像压缩编码"><a href="#图像压缩编码" class="headerlink" title="图像压缩编码"></a>图像压缩编码</h5><p>是在不损失图像质量或少损失图像质量的前提下,尽可能地减少图像的存储量，以满足图像存储和实时传输应用需求的一种技术。</p><h5 id="彩色图像处理"><a href="#彩色图像处理" class="headerlink" title="彩色图像处理"></a>彩色图像处理</h5><p>颜色是一个强有力的描绘子，它常常可简化目标物的识别和提取。人可以辫别几千种不同的颜色，但只能区分出几十种灰度级，这使得颜色在人工图像分析中显得特别重要。</p><h5 id="图像的三维重建"><a href="#图像的三维重建" class="headerlink" title="图像的三维重建"></a>图像的三维重建</h5><p>由物体截面投影来重建截面图像的一种图像处理技术。最典型的应用是医学上的计算机断层摄影技术(CT)。它用于人体头部、腹部等内部器官的无损伤诊断，其基本方法就是根据人体截面投影，经过计算机处理来重建截面图像。</p><h5 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h5><p>是图像处理技术中最为困难的任务之一，其基本思路是把一幅图像划分成背景和目标，从而提取感兴趣的目标来。</p><h5 id="图像的表示和描述"><a href="#图像的表示和描述" class="headerlink" title="图像的表示和描述"></a>图像的表示和描述</h5><p>基本思路是通过对图像中感兴趣的特征的定性和定量描述，从而赋予识别出的目标以符号标识和解释。</p><h3 id="1-3-数字图像处理技术应用领域（了解）"><a href="#1-3-数字图像处理技术应用领域（了解）" class="headerlink" title="1.3 *数字图像处理技术应用领域（了解）"></a>1.3 *数字图像处理技术应用领域（了解）</h3><p>图像处理技术的主要应用领域有：<br>生物医学、遥感技术、工业生产、军事技术、通信技术、侦缉破案、气象预报、宇宙探索、考古等，已经遍布国民经济的各个领域。</p><h4 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h4><h5 id="20世纪20年代：报纸业"><a href="#20世纪20年代：报纸业" class="headerlink" title="20世纪20年代：报纸业"></a>20世纪20年代：报纸业</h5><p>Bartlane电缆图片传输系统:大幅提高传输速度；色调质量和分辨率改善<br>1921年，电报打印机，5个灰度级；1922年，穿孔纸带，5个灰度级；1929年，15级灰度</p><h5 id="1964年：航天技术"><a href="#1964年：航天技术" class="headerlink" title="1964年：航天技术"></a>1964年：航天技术</h5><p>图像增强和复原技术；美国JPL（喷气推进）实验室处理卫星发射回来的月球表</p><h5 id="20世纪70年代：遥感卫星和医学"><a href="#20世纪70年代：遥感卫星和医学" class="headerlink" title="20世纪70年代：遥感卫星和医学"></a>20世纪70年代：遥感卫星和医学</h5><p>·图像增强和图像识别<br>·利用遥感图片，进行地质资源探测，农作物估产，水文气象监测等<br>·图像重构<br>·X光断层图像重构技术，英国G.N.Hounsfield 第一台脑断层摄像仪应用</p><h5 id="80年代末到90年代：多媒体技术"><a href="#80年代末到90年代：多媒体技术" class="headerlink" title="80年代末到90年代：多媒体技术"></a>80年代末到90年代：多媒体技术</h5><p>高速计算机和大规模集成电路的发展：图像压缩和多媒体技术；文本图像的分析和理解，文字的识别取得重大的进展；图像通讯和传输的广泛应用</p><h4 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h4><h5 id="医学"><a href="#医学" class="headerlink" title="医学"></a>医学</h5><p>通过CT及核磁共振、超声波、 X射线成像的分析等，可提供医学诊断依据。</p><h5 id="气象预报"><a href="#气象预报" class="headerlink" title="气象预报"></a>气象预报</h5><p>获取气象云图进行测绘、判读等</p><h5 id="遥感"><a href="#遥感" class="headerlink" title="遥感"></a>遥感</h5><p>农、林等资源的调查，农作物长势监测，自然灾害监测、预报，地势、地貌测绘以及地质构造解译、找矿，环境污染检测等等。</p><h5 id="工业生产"><a href="#工业生产" class="headerlink" title="工业生产"></a>工业生产</h5><p>无损探伤，石油勘探，生产过程自动化（识别零件，装配质量检查），工业机器人研制等</p><h5 id="军事"><a href="#军事" class="headerlink" title="军事"></a>军事</h5><p>航空及卫星侦察照片的测绘、判读，雷达、 声纳图像处理，导弹制导，军事仿真等</p><h5 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h5><p>图像传真，数字电视、网络可视聊天、可视电话网页动画等。</p><h5 id="公安"><a href="#公安" class="headerlink" title="公安"></a>公安</h5><p>指纹识别，印签、伪钞识别，安检，手迹、印记鉴别分析等。</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>广告设计和计算机合成图像（sora）</p><h2 id="第二讲-数字图像处理的基础"><a href="#第二讲-数字图像处理的基础" class="headerlink" title="第二讲 数字图像处理的基础"></a>第二讲 数字图像处理的基础</h2><h3 id="2-1-电磁波谱与可见光谱"><a href="#2-1-电磁波谱与可见光谱" class="headerlink" title="2.1 电磁波谱与可见光谱"></a>2.1 电磁波谱与可见光谱</h3><h4 id="电磁辐射波"><a href="#电磁辐射波" class="headerlink" title="电磁辐射波"></a>电磁辐射波</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.在实际的图像处理应用中，最主要的图像来源于电磁辐射成像。<br><span class="hljs-attribute">2</span>.电磁辐射波包括无线电波、微波、红外线、可见光、紫外线、X射线、γ射线。<br><span class="hljs-attribute">3</span>.电磁辐射波的波谱范围很广，波长最长的是无线电波为<span class="hljs-number">3</span>×<span class="hljs-number">10</span>^<span class="hljs-number">2</span>m，其波长是可见光波长的几十亿倍；波长最短的是γ射线，波长为<span class="hljs-number">3</span>×<span class="hljs-number">10</span>^-<span class="hljs-number">17</span>m，其波长比可见光小几百万倍。<br></code></pre></td></tr></table></figure><h4 id="太阳的电磁辐射波"><a href="#太阳的电磁辐射波" class="headerlink" title="太阳的电磁辐射波"></a>太阳的电磁辐射波</h4><p>1.太阳的电磁辐射波恰好主要占据整个可见光谱范围。<br>2.可见光随波长的不同依次呈现出紫、蓝、绿、黄、橙(橘红)、红六种颜色，白光是由不同颜色的可见光线混合而成的。<br>3.人从一个物体感受到的颜色是由物体反射的可见光的特性决定的，若一个物体反射的光在所有可见光波长范围内是平衡的，则对观察者来说显示的是白色；若一个物体只反射可见光谱中有限范围的光，则物体就呈现某种颜色</p><h4 id="相关概念（比较重要）"><a href="#相关概念（比较重要）" class="headerlink" title="相关概念（比较重要）"></a>相关概念（比较重要）</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">单色光：仅有单一波长成份的光<br>复合光：含有两种以上波长成份的光<br>有色光：有色彩的光。单色光和复合光都是有色彩的光。<br>消色光：没有色彩的光<br>消色光就是观察者看到的黑白电视的光，所以消色指白色、黑色和各种深浅程度不同的灰色。<br>☆消色光的属性仅有亮度或强度，通常用灰度级描述这种光的强度。<br></code></pre></td></tr></table></figure><h4 id="电磁辐射波的成像方法及其应用领域"><a href="#电磁辐射波的成像方法及其应用领域" class="headerlink" title="电磁辐射波的成像方法及其应用领域"></a>电磁辐射波的成像方法及其应用领域</h4><p>不同的电磁辐射波有各自的成像方式，其应用领域也不近相同。<br>紫外线验钞、γ射线扫描骨骼········</p><h3 id="2-2-人眼的视觉特性"><a href="#2-2-人眼的视觉特性" class="headerlink" title="2.2 人眼的视觉特性"></a>2.2 人眼的视觉特性</h3><h4 id="视觉系统基本构造"><a href="#视觉系统基本构造" class="headerlink" title="*视觉系统基本构造"></a>*视觉系统基本构造</h4><h5 id="眼球结构"><a href="#眼球结构" class="headerlink" title="*眼球结构"></a>*眼球结构</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">平均直径：20mm</span><br><span class="hljs-string">虹膜：</span> <span class="hljs-string">2mm~8mm控制入光量</span><br><span class="hljs-string">视网膜：图像视觉</span><br><span class="hljs-string">视锥体：颜色和细节识别</span><br><span class="hljs-number">600</span><span class="hljs-string">万~</span> <span class="hljs-number">700</span><span class="hljs-string">万</span><br><span class="hljs-string">视杆体：亮度敏感，分辨物体的明暗</span><br><span class="hljs-number">7500</span><span class="hljs-string">万~15000万</span><br></code></pre></td></tr></table></figure><h5 id="视觉过程"><a href="#视觉过程" class="headerlink" title="视觉过程"></a>视觉过程</h5><p>包括：光学过程；化学过程；神经处理过程<br>光学过程:物体在视网膜上成像<br><img src="/pic/73.png" alt="img"></p><h4 id="亮度适应能力"><a href="#亮度适应能力" class="headerlink" title="亮度适应能力"></a>亮度适应能力</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">实验表明：主观亮度，人的视觉系统感觉到的亮度与进入人眼的光的强度成对数关系。<br>特点1：人眼亮度适应总的动态范围相当大<br>特点2：外界光强确定后人眼亮度适应的动态范围并不大<br>特点3：当外界光强变化时，人眼亮度又适应另一个小的动态范围。<br>所以有如下发现：<br></code></pre></td></tr></table></figure><p>明亮-&gt;较暗<br>逐渐能够看清物体暗光适应(20<del>30s)<br>较暗-&gt;明亮<br>逐渐能够看清物体亮光适应(1</del>2s)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">人眼对从亮突变到暗环境的适应能力称为暗适应性。<br>人眼对亮度变化跟踪滞后的性质称为视觉惰性（短暂的记忆特性）。<br></code></pre></td></tr></table></figure><h4 id="同时对比度"><a href="#同时对比度" class="headerlink" title="同时对比度"></a>同时对比度</h4><p>亮度对比：背景亮度不同，人眼所感受的主观亮度值也不一样。<br>亮背景下显得暗、暗背景下显得亮。这种效应就叫同时对比度。</p><h4 id="亮度区分能力"><a href="#亮度区分能力" class="headerlink" title="*亮度区分能力"></a>*亮度区分能力</h4><p>假设一个平面如磨砂玻璃一样散光，被1个强度为I且可以变化的光源从背后照亮，1个照度增量为△I，像短促闪光一样加在均匀照明的平面上，可使人感到平面中间像1个圆形亮点。<br>如果△I不够亮，实验者没有感知上的变化，当△I逐步增强，感知上发生变化。如果50％的机会感知亮度变化，则量△I&#x2F;I为韦伯率，小的韦伯率表示可区分强度的小变化，有较好的亮度区分能力；大的韦伯率表示只有大的强度变化才能区分，有较差的亮度区分能力。</p><h4 id="马赫带"><a href="#马赫带" class="headerlink" title="*马赫带"></a>*马赫带</h4><p>实际亮度永远比视觉亮度要高</p><h4 id="视觉错觉"><a href="#视觉错觉" class="headerlink" title="视觉错觉"></a>视觉错觉</h4><p>长度与透视、曲线正方形等···</p><h3 id="2-3-图像的采样和量化（数字化）"><a href="#2-3-图像的采样和量化（数字化）" class="headerlink" title="2.3 图像的采样和量化（数字化）"></a>2.3 图像的采样和量化（数字化）</h3><h4 id="☆图像成像模型（不知道入射分量和反射分量是什么东西）"><a href="#☆图像成像模型（不知道入射分量和反射分量是什么东西）" class="headerlink" title="☆图像成像模型（不知道入射分量和反射分量是什么东西）"></a>☆图像成像模型（不知道入射分量和反射分量是什么东西）</h4><p>f (x,y) 与 i (x, y ) 和 r (x, y ) 都成正比<br>入射分量 i (x, y)的值是由光源决定的<br>反射分量 r (x, y)的值是由场景中的目标特性所决定的<br>{典型值：黑天鹅绒0.01;不绣钢0.65; 粉刷的白墙平面0.80;白雪0.93}</p><h4 id="主要技术"><a href="#主要技术" class="headerlink" title="*主要技术:"></a>*主要技术:</h4><p>1.成像：光信息－&gt;电信号<br>2.模数转换（A&#x2F;D Converter ）</p><h4 id="关键部件：固体成像设备"><a href="#关键部件：固体成像设备" class="headerlink" title="*关键部件：固体成像设备"></a>*关键部件：固体成像设备</h4><p>1.电荷耦合器件CCD<br>利用电荷存储、传送和读取方式进行工作<br>特点：精确、尺寸小、灵敏度高、分辨率高<br>主要设备：摄象机、扫描仪、数码相机<br>2.互补型金属氧化物半导体CMOS<br>特点：集成性好，体积更小<br>主要设备：可摄像手机<br>3.电荷注射器件CID<br>对光的灵敏度低，随机访问像</p><h4 id="采样（确定坐标）"><a href="#采样（确定坐标）" class="headerlink" title="采样（确定坐标）"></a>采样（确定坐标）</h4><p>空间坐标的离散化称为空间采样，简称采样，确定了图像的空间分辨率<br>即用空间上部分点的灰度值代表图像。这些点称为采样点<br>采样时一般取2的整数次幂的值</p><h4 id="量化-把灰度值分成多少部分"><a href="#量化-把灰度值分成多少部分" class="headerlink" title="量化(把灰度值分成多少部分)"></a>量化(把灰度值分成多少部分)</h4><p>对采样点亮度（灰度）值的离散化过程。确定了图像的灰（幅）度分辨率</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">两种量化：<br><span class="hljs-section">均匀量化: 将样点灰度级值等间隔分档取整，称为均匀量化</span><br><span class="hljs-section">非均匀量化: 将样点灰度级值不等间隔分档取整</span><br></code></pre></td></tr></table></figure><p>量化时一般取2的整数次幂的值</p><h4 id="数字图像表示"><a href="#数字图像表示" class="headerlink" title="数字图像表示"></a>数字图像表示</h4><p><img src="/pic/74.png" alt="img"><br>下图的mnk只是想表示MNG为2的整数次幂，没什么别的意思<br><img src="/pic/75.png" alt="img"><br>例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">存储<span class="hljs-number">1</span>幅<span class="hljs-number">32</span> * <span class="hljs-number">32</span>，<span class="hljs-number">16</span>个灰度级的图需要 <span class="hljs-number">4</span>,<span class="hljs-number">096</span> bit<br>存储<span class="hljs-number">1</span>幅<span class="hljs-number">128</span> * <span class="hljs-number">128</span>，<span class="hljs-number">64</span>个灰度级的图需要 <span class="hljs-number">98</span>,<span class="hljs-number">304</span> bit<br>存储<span class="hljs-number">1</span>幅<span class="hljs-number">512</span> * <span class="hljs-number">512</span>，<span class="hljs-number">256</span>个灰度级的图需要 <span class="hljs-number">2</span>,<span class="hljs-number">097</span>,<span class="hljs-number">152</span> bit<br></code></pre></td></tr></table></figure><h4 id="分辨率变化所产生的效果"><a href="#分辨率变化所产生的效果" class="headerlink" title="分辨率变化所产生的效果"></a>分辨率变化所产生的效果</h4><h5 id="空间分辨率"><a href="#空间分辨率" class="headerlink" title="空间分辨率"></a>空间分辨率</h5><p>在抽样时，若横向的像素数（列数）为M ，纵向的像素数（行数）为N，则图像总像素数为M*N个像素。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">结论:</span><br>采样间隔越大，所得图像像素数越少，空间分辨率低，质量差，严重时出现马赛克效应；<br>采样间隔越小，所得图像像素数越多，空间分辨率高，图像质量好，但数据量大。<br></code></pre></td></tr></table></figure><h5 id="灰度分辨率"><a href="#灰度分辨率" class="headerlink" title="灰度分辨率"></a>灰度分辨率</h5><p>随着灰度分辨率的降低，图像的细节信息在逐渐损失，伪轮廓信息在逐渐增加。<br>由此也说明：灰度分辨率（k）越低，图像的视觉效果越差</p><h5 id="空间和灰度分辨率同时变化"><a href="#空间和灰度分辨率同时变化" class="headerlink" title="空间和灰度分辨率同时变化"></a>空间和灰度分辨率同时变化</h5><p>量化等级越多，所得图像层次越丰富，灰度分辨率高，图像质量好，但数据量大；<br>量化等级越少，图像层次欠丰富，灰度分辨率低，会出现假轮廓现象，图像质量变差，但数据量小。</p><h3 id="2-4-像素间的关系（空间）"><a href="#2-4-像素间的关系（空间）" class="headerlink" title="2.4 像素间的关系（空间）"></a>2.4 像素间的关系（空间）</h3><p>图像由像素组成，像素在图像空间上按规律排列，相互之间有一定的联系。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">像素的邻域与连接<br>连通性<br>距离度量<br></code></pre></td></tr></table></figure><h4 id="像素的邻域-邻接关系"><a href="#像素的邻域-邻接关系" class="headerlink" title="像素的邻域-邻接关系"></a>像素的邻域-邻接关系</h4><p>邻接仅考虑像素间的空间关系<br><img src="/pic/76.png" alt="img"></p><h4 id="像素的连接"><a href="#像素的连接" class="headerlink" title="像素的连接"></a>像素的连接</h4><p>空间上邻接且像素灰度值相似（条件更苛刻）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">判断两个像素是否连接<br>① 是否接触（邻接）<br>② 灰度值是否满足某个特定的相似准则。灰度值相等 或 同在一个灰度值集合中<br></code></pre></td></tr></table></figure><p>注意在4连接和8连接同时存在时忽略8连接<br><img src="/pic/77.png" alt="img"><br><img src="/pic/78.png" alt="img"></p><h4 id="像素的连通"><a href="#像素的连通" class="headerlink" title="像素的连通"></a>像素的连通</h4><p>反映两个像素间的空间关系</p><h4 id="通路（邻接）"><a href="#通路（邻接）" class="headerlink" title="通路（邻接）"></a>通路（邻接）</h4><p>像素p(x, y)到像素q(s, t)的一条通路由一系列具有坐标<br>(x0, y0), (x1, y1) ,…,(xi, yi) ,…,(xn, yn)的独立像素组成。这<br>里 (x, y)&#x3D; (x0, y0), (xn, yn) &#x3D; (s, t),且 (xi, yi)与 (xi-1, yi-1)邻<br>接。其中1≤i≤n，n为通路长度<br>• 通路种类：4-通路；8-通路</p><h4 id="连通（连接）"><a href="#连通（连接）" class="headerlink" title="连通（连接）"></a>连通（连接）</h4><p>通路上的所有像素灰度值满足相似准则即 ：(xi, yi)与 (xi-1, yi-1)连接<br>• 种类：4-连通；8-连通；m-连通<br><img src="/pic/79.png" alt="img"></p><h4 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h4><p>• 定义：对于像素 p, q和 z, 分别具有坐标(x, y), (s, t ), (u, v)</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">如果：<br><span class="hljs-built_in">D</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">p</span><span class="hljs-operator">,</span> <span class="hljs-variable">q</span><span class="hljs-punctuation">)</span>≥<span class="hljs-number">0</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">D</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">p</span><span class="hljs-operator">,</span> <span class="hljs-variable">q</span><span class="hljs-punctuation">)</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-operator">,</span> 当且仅当 <span class="hljs-variable">p</span><span class="hljs-operator">=</span><span class="hljs-variable">q</span> <span class="hljs-punctuation">]</span><br><span class="hljs-built_in">D</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">p</span><span class="hljs-operator">,</span> <span class="hljs-variable">q</span><span class="hljs-punctuation">)</span><span class="hljs-operator">=</span> <span class="hljs-built_in">D</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">q</span><span class="hljs-operator">,</span> <span class="hljs-variable">p</span><span class="hljs-punctuation">)</span><br><span class="hljs-built_in">D</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">p</span><span class="hljs-operator">,</span> <span class="hljs-variable">z</span><span class="hljs-punctuation">)</span> ≤ <span class="hljs-built_in">D</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">p</span><span class="hljs-operator">,</span> <span class="hljs-variable">q</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">D</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">q</span><span class="hljs-operator">,</span> <span class="hljs-variable">z</span><span class="hljs-punctuation">)</span><br>则<span class="hljs-built_in">D</span> 是距离函数或度量<br></code></pre></td></tr></table></figure><p><img src="/pic/80.png" alt="img"><br><img src="/pic/81.png" alt="img"><br><img src="/pic/82.png" alt="img"></p><h3 id="2-5-图像文件类型"><a href="#2-5-图像文件类型" class="headerlink" title="2.5 图像文件类型"></a>2.5 图像文件类型</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">分类：<br>按照图像的动态特性：静止图像和运动图像<br>按照图像的色彩：灰度图像和彩色图像<br>按照图像的维数：二维图像，三维图像和多维图像。<br></code></pre></td></tr></table></figure><p>位图:<br>位图是通过许多像素点表示一幅图像，每个像素具有颜色属性和位置属性。<br>位图分成如下四种：二值图像、亮度图像、索引图像和RGB图像</p><h4 id="二值图像"><a href="#二值图像" class="headerlink" title="二值图像"></a>二值图像</h4><p>二值图像只有黑白两种颜色，一个像素仅占1，0表示黑，1表示白，或相反</p><h4 id="亮度图像"><a href="#亮度图像" class="headerlink" title="亮度图像"></a>亮度图像</h4><p>在亮度图像中，像素灰度级用8 表示，所以每个像素都是介于黑色和白色之间的256（&#x3D;256）种灰度中的一种。</p><h4 id="索引图像"><a href="#索引图像" class="headerlink" title="索引图像"></a>索引图像</h4><p>颜色是预先定义的（索引颜色）。索引颜色的图像最多只能显示256种颜色。<br>由数据矩阵X和色彩映射矩阵map组成。X是一个整数的数据矩阵。矩阵map是一个大小为L×3，取值在[0，1]的double类的数组，其长度L同它所定义的颜色数目相等。</p><h4 id="RGB图像"><a href="#RGB图像" class="headerlink" title="RGB图像"></a>RGB图像</h4><p>一幅RGB图像就是彩色像素有一个M×N×3数组, 其中每一个彩色像素点都是在特定空间位置的彩色图像对应的红, 绿, 蓝三个分量。“真彩色”是RGB颜色的另一种叫法。在真彩色图像中，每一个像素由红、绿和蓝三个字节组成，每个字节为8 ，表示0到255之间的不同的亮度值，这三个字节组合可以产生1670万种不同的颜色。</p><h2 id="第三讲-图像基本运算"><a href="#第三讲-图像基本运算" class="headerlink" title="第三讲 图像基本运算"></a>第三讲 图像基本运算</h2><h3 id="3-1-图像基本运算概述型"><a href="#3-1-图像基本运算概述型" class="headerlink" title="3.1 图像基本运算概述型"></a>3.1 图像基本运算概述型</h3>]]></content>
    
    
    <categories>
      
      <category>大学学习(大一下)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理与应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习与大数据分析技术</title>
    <link href="/2024/03/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/"/>
    <url>/2024/03/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习与大数据分析技术"><a href="#机器学习与大数据分析技术" class="headerlink" title="机器学习与大数据分析技术"></a>机器学习与大数据分析技术</h1><h2 id="机器学习绪论"><a href="#机器学习绪论" class="headerlink" title="机器学习绪论"></a>机器学习绪论</h2>]]></content>
    
    
    <categories>
      
      <category>大学学习(大一下)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序设计基础</title>
    <link href="/2024/03/23/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/03/23/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="程序设计基础"><a href="#程序设计基础" class="headerlink" title="程序设计基础"></a>程序设计基础</h1><h2 id="第四章-数组"><a href="#第四章-数组" class="headerlink" title="第四章  数组"></a>第四章  数组</h2><h3 id="4-5-动态储存"><a href="#4-5-动态储存" class="headerlink" title="4.5  动态储存"></a>4.5  动态储存</h3><p>C++的动态存储分配机制可以根据需要在程序运行时建立和撤销对象</p><h4 id="4-5-1-new和delete操作符"><a href="#4-5-1-new和delete操作符" class="headerlink" title="4.5.1  new和delete操作符"></a>4.5.1  new和delete操作符</h4><p>new 运算符动态分配堆内存，从堆分配一块“类型”大小的存储空间，返回首地址<br>delete 运算符释放已分配的内存空间</p><h5 id="☆new的使用形式"><a href="#☆new的使用形式" class="headerlink" title="☆new的使用形式"></a>☆new的使用形式</h5><p>指针变量 &#x3D; new 类型（常量-&gt;可以不写，因为是初始化值）<br>指针变量 &#x3D; new 类型[表达式]；<br>☆创建数组对象时，不能为对象指定初始值</p><h5 id="☆delete的使用形式"><a href="#☆delete的使用形式" class="headerlink" title="☆delete的使用形式"></a>☆delete的使用形式</h5><p>delete 指针变量<br>delete [] 指针变量 ；<br>指针变量必须是new出来的。建议delete完之后再给指针赋一个NULL值。</p><h4 id="4-5-2-动态储存的应用"><a href="#4-5-2-动态储存的应用" class="headerlink" title="4.5.2  动态储存的应用"></a>4.5.2  动态储存的应用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* p = <span class="hljs-literal">NULL</span>;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<span class="hljs-comment">//初始化存储区</span><br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)      <span class="hljs-comment">//☆☆☆用于判断内存是否申请成功</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;allocation faiure\n&quot;</span>;<br>&#125;<br>*p = <span class="hljs-number">20</span>;<br>cout &lt;&lt; *p &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="☆动态数组"><a href="#☆动态数组" class="headerlink" title="☆动态数组"></a>☆动态数组</h4><h5 id="一般的动态数组"><a href="#一般的动态数组" class="headerlink" title="一般的动态数组"></a>一般的动态数组</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std ;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-type">int</span> * p = <span class="hljs-literal">NULL</span> , * t ;  <span class="hljs-type">int</span>  i ;<br>   p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [<span class="hljs-number">10</span>] ;<br>   <span class="hljs-keyword">if</span> ( p == <span class="hljs-literal">NULL</span> )<br>     &#123; cout &lt;&lt; <span class="hljs-string">&quot;allocation faiure\n&quot;</span> ;  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br>   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i ++ ) <br>       p[i] = <span class="hljs-number">100</span> + i ;<span class="hljs-comment">//先给数组赋值</span><br>   cout &lt;&lt; endl ;<br>   <span class="hljs-keyword">for</span> ( t = p ; t &lt; p+<span class="hljs-number">10</span> ; t ++ ) <br>       cout &lt;&lt; *t &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> ;<span class="hljs-comment">//再利用*t输出指针数组</span><br>   cout &lt;&lt; endl ;<br>   <span class="hljs-keyword">delete</span> [] p ;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="函数申请动态数组"><a href="#函数申请动态数组" class="headerlink" title="函数申请动态数组"></a>函数申请动态数组</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">App</span><span class="hljs-params">(<span class="hljs-type">int</span>*&amp; pa, <span class="hljs-type">int</span> n)</span></span>;<span class="hljs-comment">//☆☆☆注意一下如果在函数体内new一个对象，则一定要用指针参数的</span><br>                                  引用<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* ary = <span class="hljs-literal">NULL</span>, * t, i, n;<br>cout &lt;&lt; <span class="hljs-string">&quot;n= &quot;</span>;   cin &gt;&gt; n;<br><span class="hljs-built_in">App</span>(ary, n);<span class="hljs-comment">//注意一下，这个函数的作用只是为数组创造一个空间，</span><br>                  调用函数时实参ary的值（<span class="hljs-literal">NULL</span>）赋给形参变量<span class="hljs-function">pa</span><br><span class="hljs-function"><span class="hljs-title">for</span> <span class="hljs-params">(i = <span class="hljs-number">0</span>; i &lt; n; i++)</span></span><br><span class="hljs-function"></span>&#123;<br>ary[i] = <span class="hljs-number">10</span> + i; cout &lt;&lt; ary[i]&lt;&lt;endl;<span class="hljs-comment">//☆☆☆如果修改ary的值那么将会内存泄漏</span><br>&#125;<br><span class="hljs-keyword">delete</span>[]ary;<br>    ary=<span class="hljs-literal">NULL</span>；<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-built_in">App</span>(<span class="hljs-type">int</span>*&amp; pa, <span class="hljs-type">int</span> len)<br>&#123;<br>pa = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[len];<span class="hljs-comment">//函数App执行new操作把地址写入pa，与ary无关</span><br><span class="hljs-keyword">if</span> (pa == <span class="hljs-literal">NULL</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;allocation faiure\n&quot;</span>; <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) pa[i] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第五章-集合与结构"><a href="#第五章-集合与结构" class="headerlink" title="第五章  集合与结构"></a>第五章  集合与结构</h2><h3 id="5-5-☆链表"><a href="#5-5-☆链表" class="headerlink" title="5.5  ☆链表"></a>5.5  ☆链表</h3><p>单向链表的存取方式：顺序存取<br>头指针：head，存在的目的是为了找到node1</p><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p>所谓静态链表，指的是每个节点并不是按照程序运行时的需求而动态创建的，而是在一开始就创建好，并用指针连接起来。和数组比较类似，但是时顺序访问，不能通过下标访问。</p><h4 id="动态链表"><a href="#动态链表" class="headerlink" title="动态链表"></a>动态链表</h4><h2 id="第六章-类与对象"><a href="#第六章-类与对象" class="headerlink" title="第六章  类与对象"></a>第六章  类与对象</h2><h3 id="第三节-类的其他成员"><a href="#第三节-类的其他成员" class="headerlink" title="第三节  类的其他成员"></a>第三节  类的其他成员</h3><h4 id="常成员（常量）"><a href="#常成员（常量）" class="headerlink" title="常成员（常量）"></a>常成员（常量）</h4><p>定义常成员常用const约束，初始化之后被约束，不可修改。</p><h5 id="常数据成员"><a href="#常数据成员" class="headerlink" title="常数据成员"></a>常数据成员</h5><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs axapta">       <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> M;    <span class="hljs-comment">//说明常数据成员</span><br>       类名() : M(<span class="hljs-number">5</span>) &#123; &#125; <span class="hljs-comment">//用初始式对常数据成员赋值</span><br>此后M的值就不可修改了。<br><span class="hljs-meta">##### 常对象</span><br>让对象的全部成员在作用域中约束为只读<br>     <span class="hljs-meta">#include&lt;iostream&gt;</span><br>     <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>     <span class="hljs-keyword">class</span> <span class="hljs-title class_">T_class</span><br>     &#123;<br>     <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> a, b;<br>    T_class(<span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j) &#123; a = i; b = j; &#125;<br>      &#125;;<br>      <span class="hljs-built_in">int</span> main()<br>     &#123;<br>    <span class="hljs-keyword">const</span> T_<span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    T_<span class="hljs-keyword">class</span> <span class="hljs-title class_">t2</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-comment">//t1.a=5;  错误</span><br>    <span class="hljs-comment">//t1.b=6;  错误</span><br>    t2.a = <span class="hljs-number">7</span>;<br>    t2.b = <span class="hljs-number">8</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;t1.a=&quot;</span> &lt;&lt; t1.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;t1.b=&quot;</span> &lt;&lt; t1.b &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;t2.a=&quot;</span> &lt;&lt; t2.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;t2.b=&quot;</span> &lt;&lt; t2.b &lt;&lt; endl;<br>     &#125;<br></code></pre></td></tr></table></figure><h5 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h5><p>常函数的this指针被约束为指向常量的常指针。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span><br>&#123;<br>   <span class="hljs-built_in">int</span> a;<br>   <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">g</span>()<span class="hljs-keyword">const</span></span>&#123;<span class="hljs-keyword">return</span> a++&#125;;  <span class="hljs-comment">//这种表述是错误的，因为常成员函数不能修改数据成员</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><pre><code class="hljs"> 类成员冠以static声明时，称为静态成员。  静态数据成员为同类对象共享。 静态成员函数与静态数据成员协同操作。  </code></pre><h5 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h5><pre><code class="hljs"> #include&lt;iostream&gt; using namespace std; class  counter &#123;    static  int  num;                               //设定静态成员 public:    void  setnum(int i) &#123; num = i; &#125;    void  shownum() &#123; cout &lt;&lt; num &lt;&lt; &#39;\t&#39;; &#125; &#125;; int  counter::num = 0;        //类外定义num int main() &#123;    counter  a, b;    a.shownum();    b.shownum();    a.setnum(10);    a.shownum();    b.shownum();                //    这里a和b的输出都是10，因为静态数据共享，所以a中的num变了，b中的也要变    cout &lt;&lt; endl; &#125;</code></pre><h5 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h5><pre><code class="hljs"> 静态成员函数数冠以关键字static 静态成员函数没有this指针，只能对静态数据操作 在类外调用静态成员函数用 “类名 :: ”作限定词，或通过对象调用 性质上和静态数据成员差不多</code></pre><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><pre><code class="hljs"> 友元是对类操作的辅助手段。友元能够引用类中本来被隐蔽的信息 使用友元目的是基于程序的运行效率 运算符重载的某些场合需要使用友元 友元可以是函数，也可以是类 友元关系是非传递的。即 Y 是 X 的友元，Z 是 Y 的友元，但 Z 不一定是X的友元</code></pre><h5 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h5><pre><code class="hljs"> class Point &#123; public:    Point(double xi, double yi) &#123; X = xi; Y = yi; &#125;    friend double Distance(Point&amp; a, Point&amp; b);  //传入两个类类型的参数 private:  double X, Y;                          //X和Y不可直接访问 &#125;; double Distance(Point&amp; a, Point&amp; b) &#123;    double dx = a.X - b.X;                       //通过友元函数访问X    double dy = a.Y - b.Y;                       //通过友元函数访问Y    return sqrt(dx * dx + dy * dy); &#125;</code></pre><h5 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h5><pre><code class="hljs"> 若F类是A类的友元类，则F类的所有成员函数都是A类的友元函数 友元类通常设计为一种对数据操作或类之间传递消息的辅助类 </code></pre><p>来看一个例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs csharp"> <span class="hljs-meta">#include&lt;iostream&gt;</span><br> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span> ;<br> <span class="hljs-keyword">class</span> <span class="hljs-title">A</span><br> &#123; friend <span class="hljs-keyword">class</span> <span class="hljs-title">B</span> ;                                    <span class="hljs-comment">//这里说明了B是A的一个友元类</span><br>   <span class="hljs-keyword">public</span> :<br>       <span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">Display</span>()</span> &#123; cout &lt;&lt; x &lt;&lt; endl ; &#125; ;<br>   <span class="hljs-keyword">private</span> :<br>    <span class="hljs-built_in">int</span>  x ;<br> &#125; ;<br>plan1：在B中为A创建一个类对象<br> <span class="hljs-keyword">class</span>  <span class="hljs-title">B</span><br> &#123; <span class="hljs-keyword">public</span> :<br>       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Set</span> (<span class="hljs-params"> <span class="hljs-built_in">int</span> i </span>)</span> &#123; Aobject . x = i ; &#125;        <span class="hljs-comment">//利用友元类访问A类中的private中的x</span><br>       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Display</span> ()</span>  &#123; Aobject . Display () ; &#125;     <span class="hljs-comment">//利用友元类调用A类中的函数</span><br>   <span class="hljs-keyword">private</span> :<br>    A  Aobject ;                                       <span class="hljs-comment">//这里B类为A类创建了一个类对象，并且在public中使用类对象</span><br> &#125; ;<br> <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br> &#123; B  Bobject ;<br>   Bobject . Set ( <span class="hljs-number">100</span> ) ;<br>   Bobject . Display () ;<br> &#125;<br>plan2：直接对A操作<br> <span class="hljs-keyword">class</span>  <span class="hljs-title">B</span><br> &#123;<br> <span class="hljs-keyword">public</span>:<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Set</span>(<span class="hljs-params">A&amp;Aobject,<span class="hljs-built_in">int</span> i</span>)</span> &#123; Aobject.x = i; &#125;       <span class="hljs-comment">//调用函数时应当放入一个A类的类对象和一个整形数据作为实参</span><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>(<span class="hljs-params">A&amp; Aobject</span>)</span> &#123; Aobject.Display(); &#125;    <span class="hljs-comment">//调用函数时应当放入A的一个类对象</span><br> &#125;;<br> <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br> &#123;<br> B Bobject;<br> A Aobject;<br> Bobject.Set(Aobject, <span class="hljs-number">100</span>);<br> Bobject.Display(Aobject);<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="第四节-类的包含"><a href="#第四节-类的包含" class="headerlink" title="第四节  类的包含"></a>第四节  类的包含</h3><p>类的包含（称为has A）是程序设计中一种软件重用技术。即定义一个新的类时，通过编译器把另一个类 “抄”进来。 当一个类中含有已经定义的类类型成员，带参数的构造函数对数据成员初始化，须使用初始化语法形式。<br>构造函数 ( 变元表 ) : 对象成员1( 变元表 ) , … , 对象成员n ( 变元表 ) ； </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-built_in">int</span> x) :a(x) &#123;&#125;                                <span class="hljs-comment">//&quot;a（x）&quot;等价于把a=x放入大括号内</span><br><span class="hljs-built_in">int</span> a;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>B(<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) : aa(x) &#123; b = y; &#125;               <span class="hljs-comment">//利用类对象aa给B类中的x赋值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">out</span>()</span> &#123; cout &lt;&lt; <span class="hljs-string">&quot;aa = &quot;</span> &lt;&lt; aa.a &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl; &#125;  <span class="hljs-comment">//利用创建的类对象aa调用A类中的成员</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">int</span> b;<br>A aa;                                             <span class="hljs-comment">//为A类创建了一个名字叫做aa的类对象</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br><span class="hljs-function">B <span class="hljs-title">objB</span>(<span class="hljs-params"><span class="hljs-number">3</span>, <span class="hljs-number">5</span></span>)</span>;<br>objB.<span class="hljs-keyword">out</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第八章-继承"><a href="#第八章-继承" class="headerlink" title="第八章  继承"></a>第八章  继承</h2><h3 id="第一节-类之间的关系"><a href="#第一节-类之间的关系" class="headerlink" title="第一节  类之间的关系"></a>第一节  类之间的关系</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">has-<span class="hljs-selector-tag">A</span>：包含关系，用以描述一个类由多个“部件类”构成。实现has-<span class="hljs-selector-tag">A</span>关系用类成员表示，即一个类中的数据成员是另一种已经定义的类。<br>uses-<span class="hljs-selector-tag">A</span>：一个类部分地使用另一个类。通过类之间成员函数的相互联系，定义友元或对象参数传递实现。<br>is-<span class="hljs-selector-tag">A</span>：机制称为“继承”。关系具有传递性,不具有对称性。 <br></code></pre></td></tr></table></figure><p>具有传递性，但是不具有对称性。<br>继承 是类之间定义的一种重要关系<br>一个 B 类继承A类，或称从类 A 派生类 B<br>类 A 称为基类（父类），类 B 称为派生类（子类）</p><h3 id="第二节-基类和派生类"><a href="#第二节-基类和派生类" class="headerlink" title="第二节  基类和派生类"></a>第二节  基类和派生类</h3><p>类继承的语法形式：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ada">class 派生类名 : 基类名表<br>     &#123;<br>           数据成员和成员函数声明<br>     &#125;;<br>基类名表的构成：<br>访问控制  基类名<span class="hljs-number">1</span>， 访问控制  基类名<span class="hljs-number">2</span> ，… ， 访问控制  基类名n<br>而访问控制又表示派生类对基类的继承方式，使用关键字：<br>public公有继承  基类的公有成员<span class="hljs-comment">--&gt;派生类的公有成员;基类的保护成员--&gt;派生类的保护成员</span><br><span class="hljs-keyword">private</span>私有继承 基类的公有成员和保护成员<span class="hljs-comment">--&gt;派生类的私有成员</span><br><span class="hljs-keyword">protected</span>保护继承   基类的公有成员和保护成员<span class="hljs-comment">--&gt;派生类的保护成员</span><br>☆不论种方式继承基类，派生类都不能直接使用基类的私有成员 <br></code></pre></td></tr></table></figure><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><h5 id="公有继承"><a href="#公有继承" class="headerlink" title="公有继承"></a>公有继承</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">get_XY</span>()</span> &#123; cout &lt;&lt; <span class="hljs-string">&quot;Enter two numbers of x, y : &quot;</span>;  cin &gt;&gt; x &gt;&gt; y; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">put_XY</span>()</span> &#123; cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; &#125;<br><span class="hljs-keyword">protected</span>:    <span class="hljs-built_in">int</span> x, y;  <span class="hljs-comment">//如果要使子类能用他们，就设置成protected</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> : <span class="hljs-title">public</span> <span class="hljs-title">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">int</span>  <span class="hljs-title">get_S</span>()</span> &#123; <span class="hljs-keyword">return</span> s; &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">make_S</span>()</span> &#123; s = x * y; &#125;;    <span class="hljs-comment">// 使用基类数据成员x，y</span><br><span class="hljs-keyword">protected</span>:   <span class="hljs-built_in">int</span> s;      <span class="hljs-comment">//如果要使子类能用他，就设置成protected</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> : <span class="hljs-title">public</span> <span class="hljs-title">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">get_H</span>()</span> &#123; cout &lt;&lt; <span class="hljs-string">&quot;Enter a number of h : &quot;</span>;  cin &gt;&gt; h; &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">int</span>  <span class="hljs-title">get_V</span>()</span> &#123; <span class="hljs-keyword">return</span> v; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">make_V</span>()</span> &#123; make_S(); v = get_S() * h; &#125; <span class="hljs-comment">// 使用基类成员函数</span><br><span class="hljs-keyword">protected</span>:    <span class="hljs-built_in">int</span> h, v;<br>&#125;;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>     ···<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种方式就是将变量设置为private，利用函数调用它。语法为：对象.函数名（）；</p><h5 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h5><p>访问私有的方法和上面一样</p><h5 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h5><p>略</p><h5 id="访问声明"><a href="#访问声明" class="headerlink" title="访问声明"></a>访问声明</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">访问方式：基类类名：：函数名<br><span class="hljs-number">1.</span>访问声明仅调整名字的访问权限。被声明时，成员不能说明类型，函数不能带参数和返回值类型<br><span class="hljs-number">2.</span>访问声明不可降低或提升基类成员的可访问性。比如：<span class="hljs-keyword">protected</span>只能给<span class="hljs-keyword">protected</span>声明。<br><span class="hljs-number">3.</span>相同访问域的重载函数声明一次就都可以用了，不同访问域的不能操作，基类派生类同名的也不能操作<br></code></pre></td></tr></table></figure><h4 id="重名成员"><a href="#重名成员" class="headerlink" title="重名成员"></a>重名成员</h4><p>派生类定义了与基类同名的成员，在派生类中访问同名成员时屏蔽了基类的同名成员<br>在派生类中使用基类的同名成员，显式地使用类名限定符：类名 :: 成员 </p><h5 id="重名数据成员"><a href="#重名数据成员" class="headerlink" title="重名数据成员"></a>重名数据成员</h5><p>不重名的可以直接用”对象名.数据成员”引用<br>重名的基类成员要用”对象名.基类名::数据成员”引用</p><h5 id="重名成员函数"><a href="#重名成员函数" class="headerlink" title="重名成员函数"></a>重名成员函数</h5><p>与重名数据成员的使用方法一样。<br>派生类也是基类，基类指针可以指向派生类对象<br>派生类中定义与基类同名的成员函数，称为重载成员函数</p><h4 id="派生类中访问静态成员"><a href="#派生类中访问静态成员" class="headerlink" title="派生类中访问静态成员"></a>派生类中访问静态成员</h4><p>基类定义的静态成员，将被所有派生类共享<br>根据静态成员自身的访问特性和派生类的继承方式，在类层次体系中具有不同的访问性质<br>派生类中访问静态成员，用以下形式显式说明：<br>类名 :: 成员&#x2F; 对象名 . 成员<br>☆私有继承到派生类之后可以在派生类中使用，可以在public中用。派生类中无需声明也可以直接用函数名或成员名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123; <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">()</span> </span>&#123; i++ ; &#125;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> i;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">out</span><span class="hljs-params">()</span> </span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;static i=&quot;</span>&lt;&lt;i&lt;&lt;endl; &#125;<br>&#125;;<br><span class="hljs-type">int</span> B::i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">private</span> B<br>&#123; <span class="hljs-keyword">public</span>:    <br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">       </span>&#123; i=<span class="hljs-number">5</span>;          <span class="hljs-comment">//虽然是私有继承，但是派生类中可见</span><br>         <span class="hljs-built_in">Add</span>();         <span class="hljs-comment">//虽然是私有继承，但是在派生类中可直接调用，还不用B：：Add（）</span><br>         B::i++;<br>         B::<span class="hljs-built_in">Add</span>();<br>       &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上几行的++都是对同一个i进行操作。</p><h3 id="第三节-基类的初始化"><a href="#第三节-基类的初始化" class="headerlink" title="第三节  基类的初始化"></a>第三节  基类的初始化</h3><p>建立一个类层次后，通常创建某个派生类的对象，包括使用基类的数据和函数<br>C++提供一种机制，在创建派生类对象时用指定参数调用基类的构造函数来初始化派生类继承基类的数据<br>派生类构造函数声明为：<br>派生类构造函数 ( 变元表 ) : 基类 ( 变元表 ) , 对象成员1( 变元表 )… 对象成员n ( 变元表 ) ；<br>构造函数执行顺序：基类–&gt;对象成员–&gt;派生类</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">parent_class</span><br>&#123;<br>    <span class="hljs-type">int</span>  data1, data2;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">parent_class</span>(<span class="hljs-type">int</span>  p1, <span class="hljs-type">int</span>  p2) &#123; data1 = p1; data2 = p2; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">inc1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span>  ++data1; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">inc2</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span>  ++data2; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;data1=&quot;</span> &lt;&lt; data1 &lt;&lt; <span class="hljs-string">&quot; , data2=&quot;</span> &lt;&lt; data2 &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">derived_class</span> : <span class="hljs-keyword">private</span>  parent_class<br>&#123;<br>    <span class="hljs-type">int</span>  data3;<br>    parent_class  data4;<span class="hljs-comment">//为基类创建了一个叫做data4的类对象</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">derived_class</span>(<span class="hljs-type">int</span>  p1, <span class="hljs-type">int</span>  p2, <span class="hljs-type">int</span>  p3, <span class="hljs-type">int</span>  p4, <span class="hljs-type">int</span>  p5) : <span class="hljs-built_in">parent_class</span>(p1, p2), <span class="hljs-built_in">data4</span>(p3, p4)<br>    &#123;<br>        data3 = p5;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">inc1</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span>  parent_class::<span class="hljs-built_in">inc1</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">inc3</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span>  ++data3; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">display</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        parent_class::<span class="hljs-built_in">display</span>();   data4.<span class="hljs-built_in">display</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;data3=&quot;</span> &lt;&lt; data3 &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">derived_class  <span class="hljs-title">d1</span><span class="hljs-params">(<span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-5</span>)</span></span>;   d1.<span class="hljs-built_in">inc1</span>();     d1.<span class="hljs-built_in">display</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四节-继承的应用实例"><a href="#第四节-继承的应用实例" class="headerlink" title="第四节  继承的应用实例"></a>第四节  继承的应用实例</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//一个有点长的例子</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span><br>&#123;<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream&amp;, <span class="hljs-type">const</span> Point&amp;);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> = <span class="hljs-number">0</span>);<span class="hljs-comment">// 带默认参数的构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setPoint</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">// 对点坐标数据赋值</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125;    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> y; &#125;<br><span class="hljs-keyword">protected</span>:    <span class="hljs-type">int</span> x, y;<span class="hljs-comment">// Point类的数据成员</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Point<br>&#123;<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream&amp;, <span class="hljs-type">const</span> Circle&amp;);<span class="hljs-comment">// 友元函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Circle</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0.0</span>, <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>);<span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setRadius</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;  <span class="hljs-comment">/*置半径*/</span>          <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;     <span class="hljs-comment">/*返回半径*/</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">// 返回面积</span><br><span class="hljs-keyword">protected</span>:    <span class="hljs-type">double</span> radius;<span class="hljs-comment">// 数据成员，半径</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cylinder</span> :<span class="hljs-keyword">public</span> Circle<br>&#123;<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="hljs-type">const</span> Cylinder&amp;);    <span class="hljs-comment">// 友元函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cylinder</span>(<span class="hljs-type">double</span> h = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> r = <span class="hljs-number">0.0</span>, <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>);      <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;    <span class="hljs-comment">/* 置高度值*/</span>           <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getHeight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">/* 返回高度值*/</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;     <span class="hljs-comment">/* 返回面积*/</span>            <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">volume</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">/* 返回体积*/</span><br><span class="hljs-keyword">protected</span>:     <span class="hljs-type">double</span> height;<span class="hljs-comment">// 数据成员，高度</span><br>&#125;;<br><span class="hljs-comment">// Point 类的成员函数 </span><br><span class="hljs-comment">// 构造函数，调用成员函数对 x，y作初始化</span><br>Point::<span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>&#123;<br>    <span class="hljs-built_in">setPoint</span>(a, b);<br>&#125;<br><span class="hljs-comment">// 对数据成员置值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Point::setPoint</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; x = a;  y = b; &#125;<br><span class="hljs-comment">// 重载插入算符，输出对象数据</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream&amp; output, <span class="hljs-type">const</span> Point&amp; p)<br>&#123;<br>    output &lt;&lt; <span class="hljs-string">&#x27;[&#x27;</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><span class="hljs-comment">// Circle 类的成员函数 </span><br><span class="hljs-comment">// 带初始化式构造函数，首先调用基类构造函数</span><br>Circle::<span class="hljs-built_in">Circle</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) : <span class="hljs-built_in">Point</span>(a, b) &#123; <span class="hljs-built_in">setRadius</span>(r); &#125;<br><span class="hljs-comment">// 对半径置值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Circle::setRadius</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> </span>&#123; radius = (r &gt;= <span class="hljs-number">0</span> ? r : <span class="hljs-number">0</span>); &#125;<br><span class="hljs-comment">// 返回半径值</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Circle::getRadius</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span>  radius; &#125;<br><span class="hljs-comment">// 计算并返回面积值</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Circle::area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span>  <span class="hljs-number">3.14159</span> * radius * radius; &#125;<br><span class="hljs-comment">// 输出圆心坐标和半径值</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream&amp; output, <span class="hljs-type">const</span> Circle&amp; c)<br>&#123;<br>    output &lt;&lt; <span class="hljs-string">&quot;Center = &quot;</span> &lt;&lt; <span class="hljs-string">&#x27;[&#x27;</span> &lt;&lt; c.x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; c.y &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; <span class="hljs-string">&quot;; Radius = &quot;</span><br>        &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed | ios::showpoint) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; c.radius;<br>    <span class="hljs-keyword">return</span>  output;<br>&#125;<br>    <span class="hljs-comment">// Cylinder 类的成员函数</span><br><span class="hljs-comment">// 带初始化式构造函数，首先调用基类构造函数 </span><br>    Cylinder::<span class="hljs-built_in">Cylinder</span>(<span class="hljs-type">double</span> h, <span class="hljs-type">double</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) :<span class="hljs-built_in">Circle</span>(r, x, y) &#123; <span class="hljs-built_in">setHeight</span>(h); &#125;<br>    <span class="hljs-comment">// 对高度置值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cylinder::setHeight</span><span class="hljs-params">(<span class="hljs-type">double</span> h)</span> </span>&#123; height = (h &gt;= <span class="hljs-number">0</span> ? h : <span class="hljs-number">0</span>); &#125;<br>    <span class="hljs-comment">// 返回高度值</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Cylinder::getHeight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> height; &#125;<br>    <span class="hljs-comment">// 计算并返回圆柱体的表面积</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Cylinder::area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span>  <span class="hljs-number">2</span> * Circle::<span class="hljs-built_in">area</span>() + <span class="hljs-number">2</span> * <span class="hljs-number">3.14159</span> * radius * height; &#125;<br>    <span class="hljs-comment">// 计算并返回圆柱体的体积</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Cylinder::volume</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span>  Circle::<span class="hljs-built_in">area</span>() * height; &#125;<br>    <span class="hljs-comment">// 输出数据成员圆心坐标、半径和高度值</span><br>    ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream &amp; output, <span class="hljs-type">const</span> Cylinder &amp; cy)<br>    &#123;<br>        output &lt;&lt; <span class="hljs-string">&quot;Center = &quot;</span> &lt;&lt; <span class="hljs-string">&#x27;[&#x27;</span> &lt;&lt; cy.x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; cy.y &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; <span class="hljs-string">&quot;; Radius = &quot;</span><br>            &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed | ios::showpoint) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; cy.radius<br>            &lt;&lt; <span class="hljs-string">&quot;; Height = &quot;</span> &lt;&lt; cy.height &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">72</span>, <span class="hljs-number">115</span>)</span></span>;<span class="hljs-comment">//定义点对象并初始化</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;The initial location of p is &quot;</span> &lt;&lt; p &lt;&lt; endl;<br>        p.<span class="hljs-built_in">setPoint</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<span class="hljs-comment">//置点的新数据值</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;\nThe new location of p is &quot;</span> &lt;&lt; p &lt;&lt; endl;<span class="hljs-comment">//输出数据</span><br>        <span class="hljs-function">Circle <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">2.5</span>, <span class="hljs-number">37</span>, <span class="hljs-number">43</span>)</span></span>;<span class="hljs-comment">//定义圆对象并初始化</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;\nThe initial location and radius of c are\n&quot;</span> &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot;\nArea = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">area</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-comment">//置圆的新数据值</span><br>        c.<span class="hljs-built_in">setRadius</span>(<span class="hljs-number">4.25</span>);    c.<span class="hljs-built_in">setPoint</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>        <span class="hljs-comment">//输出圆心坐标和圆面积</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;\nThe new location and radius of c are\n&quot;</span> &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot;\nArea = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">area</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-function">Cylinder <span class="hljs-title">cyl</span><span class="hljs-params">(<span class="hljs-number">5.7</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">12</span>, <span class="hljs-number">23</span>)</span></span>;<span class="hljs-comment">//定义圆柱体对象并初始化</span><br>        <span class="hljs-comment">//输出圆柱体各数据和表面积，体积</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;\nThe initial location, radius ang height of cyl are\n&quot;</span> &lt;&lt; cyl<br>            &lt;&lt; <span class="hljs-string">&quot;Area = &quot;</span> &lt;&lt; cyl.<span class="hljs-built_in">area</span>() &lt;&lt; <span class="hljs-string">&quot;\nVolume = &quot;</span> &lt;&lt; cyl.<span class="hljs-built_in">volume</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-comment">//置圆柱体的新数据值</span><br>        cyl.<span class="hljs-built_in">setHeight</span>(<span class="hljs-number">10</span>);   cyl.<span class="hljs-built_in">setRadius</span>(<span class="hljs-number">4.25</span>);    cyl.<span class="hljs-built_in">setPoint</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>        cout &lt;&lt; <span class="hljs-string">&quot;\nThe new location, radius ang height of cyl are\n&quot;</span> &lt;&lt; cyl<br>            &lt;&lt; <span class="hljs-string">&quot;Area = &quot;</span> &lt;&lt; cyl.<span class="hljs-built_in">area</span>() &lt;&lt; <span class="hljs-string">&quot;\nVolume = &quot;</span> &lt;&lt; cyl.<span class="hljs-built_in">volume</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>解析：我们想便捷的计算点，圆和圆柱相关的东西，但它们之中有一部分参量是重复的，我们不想再重复输入，所以选择继承的方式。<br>1.点类中要有点的构造函数初始化点坐标，为点赋值的函数，返回X、Y的函数，重载输出流（定义输出类对象时输出点的坐标）<br>2.圆类中公有继承，还要有构造函数初始化点坐标和半径，为半径赋值的函数，返回半径和面积的函数，重载输出流。（定义输出类对象时输出点的坐标，半径）<br>3.圆柱类中公有继承，构造函数初始化点坐标、半径、高度，为高度赋值的函数。返回高度值的函数，返回面积的函数，返回体积的函数，重载输出流（定义输出类对象时输出点的坐标，半径，高度）。<br>在main函数中：<br>先用Point p（72，115）；创建并初始化对象<br>再利用setPoint(置点新的数据值)<br>后面的都一样，先set新的值，再通过形如area（）等函数返回要的结果。</p><h4 id="类的继承和类的包含的比较"><a href="#类的继承和类的包含的比较" class="headerlink" title="类的继承和类的包含的比较"></a>类的继承和类的包含的比较</h4><p><img src="/pic/95.png" alt="img"><br>对比两种方式我们发现，二者在Circle类中声明outpoint的方式不一样，在输出时的方式也不一样。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">继承的方式：<br>构造函数初始化对象时，利用基类名初始化<br>在派生类的函数体内要通过（类名：：函数名（））来声明；在派生类其他地方通过（类名：：函数名）来声明。<br>通过（派生类对象.函数名（））的方式调用：<br>构造函数初始化对象时，利用被包含类的对象名初始化。<br>包含的方式要通过（被包含对象名.函数名（））的方式在函数体内声明<br>通过（包含对象名.被包含对象名.函数名（））的方式调用<br></code></pre></td></tr></table></figure><h3 id="第五节-多继承"><a href="#第五节-多继承" class="headerlink" title="第五节  多继承"></a>第五节  多继承</h3><p>一个类有多个直接基类的继承关系称为多继承<br>多继承声明语法：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span>  派生类名 : 访问控制  基类名<span class="hljs-symbol">1</span> ,  访问控制  基类名<span class="hljs-symbol">2</span> ,  … , 访问控制  基类名<span class="hljs-symbol">n</span><br>    &#123;<br>         数据成员和成员函数声明<br>    &#125;；<br></code></pre></td></tr></table></figure><h4 id="多继承的派生类构造和访问"><a href="#多继承的派生类构造和访问" class="headerlink" title="多继承的派生类构造和访问"></a>多继承的派生类构造和访问</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1.多个基类的派生类构造函数可以用初始式调用基类构造函数初始化数据成员。<br>2.执行顺序与单继承构造函数情况类似。多个直接基类构造函数执行顺序取决于定义派生类时指定的各个继承基类的顺序。<br>3.一个派生类对象拥有多个直接或间接基类的成员。不同名成员访问不会出现二义性。如果不同的基类有同名成员，派生类对象访问时应该加以识别。 （同名可能会有二义性）<br></code></pre></td></tr></table></figure><p>☆若派生类在继承基类的公有函数时，公有函数有同名的函数时，不可直接调用，会有二义性。例如:<br>假设C类继承了A和B类,C有一个对象叫做d，A类和B类中各有一个叫做Get的函数，则不可通过d.Get的方法去调用Get函数（其他的可以）。如果要调用，只能用d.A::Get()&#x2F;d.B::Get()的方式调用函数；</p><h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><p>如果一个派生类从多个基类派生，而这些基类又有一个共同的基类，则在对该基类中声明的名字进行访问时，可能产生二义性。我们现在假设有一个基类B，它有两个派生类B1B2，而这两个派生类又为D的基类。</p><h5 id="非虚继承"><a href="#非虚继承" class="headerlink" title="非虚继承"></a>非虚继承</h5><p>初始化时通过B-&gt;B1,B-&gt;B2的路径初始化基类，所以两次调用了B的构造函数。若B中有变量b和对象d，则D在继承时同时继承了来自B1的b和来自B2的b，会产生二义性，所以会在调用时要显示的说明是从哪个直接基类派生的成员。d.B1.::b&#x2F;d.B2::b。</p><h5 id="虚继承-1"><a href="#虚继承-1" class="headerlink" title="虚继承"></a>虚继承</h5><p>如非虚继承所述，如果一个派生类从多个基类派生，而这些基类又有一个共同的基类，则在对该基类中声明的名字进行访问时，可能产生二义性。要使这个公共基类在派生类中只产生一个子对象，必须对这个基类声明为虚继承，使这个基类成为虚基类。 虚继承声明使用关键字virtual。<br>如假设有如上的情况，只需使B1和B2在继承时在访问控制前面加一个virtual即可。<br>则在初始化时仅调用了一次B类</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">//8.13 虚继承的测试</span><br><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-variable">using</span> <span class="hljs-variable">namespace</span> <span class="hljs-variable">std</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-variable">public</span>:<br>    <span class="hljs-title function_">B</span>(<span class="hljs-params">int</span> <span class="hljs-params">x</span> = 10)<br>    &#123;<br>        <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-variable">x</span>;<br>        <span class="hljs-variable">cout</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;Constructor called:B<span class="hljs-char escape_">\n</span>&quot;</span>;<br>    &#125;<br>    <span class="hljs-operator">~</span><span class="hljs-title function_">B</span>()<br>    &#123;<br>        <span class="hljs-variable">cout</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;Destructor called:B<span class="hljs-char escape_">\n</span>&quot;</span>;<br>    &#125;<br>    int <span class="hljs-variable">b</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B1</span> :<span class="hljs-variable">virtual</span> <span class="hljs-variable">public</span> <span class="hljs-variable">B</span>     <span class="hljs-comment">//虚继承</span><br>&#123;<br><span class="hljs-variable">public</span>:<br>    <span class="hljs-title function_">B1</span>(int <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>, int <span class="hljs-variable">y1</span> <span class="hljs-operator">=</span> <span class="hljs-number">21</span>) :<span class="hljs-title function_">B</span>(<span class="hljs-params">x1</span>)<br>    &#123;<br>        <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-variable">y1</span>;<br>        <span class="hljs-variable">cout</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;Constructor called:B1<span class="hljs-char escape_">\n</span>&quot;</span>;<br>    &#125;<br>    <span class="hljs-operator">~</span><span class="hljs-title function_">B1</span>()<br>    &#123;<br>        <span class="hljs-variable">cout</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;Destructor called:B1<span class="hljs-char escape_">\n</span>&quot;</span>;<br>    &#125;<br>    int <span class="hljs-variable">b1</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B2</span> :<span class="hljs-variable">virtual</span> <span class="hljs-variable">public</span> <span class="hljs-variable">B</span>  <span class="hljs-comment">//虚继承</span><br>&#123;<br><span class="hljs-variable">public</span>:<br>    <span class="hljs-title function_">B2</span>(int <span class="hljs-variable">x2</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>, int <span class="hljs-variable">y2</span> <span class="hljs-operator">=</span> <span class="hljs-number">22</span>) :<span class="hljs-title function_">B</span>(<span class="hljs-params">x2</span>)<br>    &#123;<br>        <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-variable">y2</span>;<br>        <span class="hljs-variable">cout</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;Constructor called:B2<span class="hljs-char escape_">\n</span>&quot;</span>;<br>    &#125;<br>    <span class="hljs-operator">~</span><span class="hljs-title function_">B2</span>()<br>    &#123;<br>        <span class="hljs-variable">cout</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;Destructor called:B2<span class="hljs-char escape_">\n</span>&quot;</span>;<br>    &#125;<br>    int <span class="hljs-variable">b2</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> :<span class="hljs-variable">public</span> <span class="hljs-variable">B1</span>, <span class="hljs-variable">public</span> <span class="hljs-title function_">B2</span><br>&#123;<br><span class="hljs-variable">public</span>:<br>    <span class="hljs-title function_">D</span>(int <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, int <span class="hljs-variable">j1</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, int <span class="hljs-variable">j2</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>, int <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>) :<span class="hljs-title function_">B</span>(<span class="hljs-variable">i</span>), <span class="hljs-title function_">B1</span>(<span class="hljs-variable">j1</span>), <span class="hljs-title function_">B2</span>(<span class="hljs-params">j2</span>)<br>    &#123;<br>        <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-variable">k</span>;<br>        <span class="hljs-variable">cout</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;Constructor called:D<span class="hljs-char escape_">\n</span>&quot;</span>;<br>    &#125;<br>    <span class="hljs-operator">~</span><span class="hljs-title function_">D</span>()<br>    &#123;<br>        <span class="hljs-variable">cout</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;Destructor called:D<span class="hljs-char escape_">\n</span>&quot;</span>;<br>    &#125;<br>    int <span class="hljs-variable">d</span>;<br>&#125;;<br><span class="hljs-variable">void</span> <span class="hljs-title function_">test</span>()<br>&#123;<br>    <span class="hljs-variable">D</span> <span class="hljs-variable">objD</span>;<br>    <span class="hljs-variable">cout</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;objD.b=&quot;</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-variable">objD</span>.<span class="hljs-property">b</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-variable">endl</span>;<br>    <span class="hljs-variable">cout</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;objD.b1=&quot;</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-variable">objD</span>.<span class="hljs-property">b1</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;<span class="hljs-char escape_">\n</span>objD.b2=&quot;</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-variable">objD</span>.<span class="hljs-property">b2</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;<span class="hljs-char escape_">\n</span>objD.d&quot;</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-variable">objD</span>.<span class="hljs-property">d</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-variable">endl</span>;<br>    <span class="hljs-variable">B1</span> <span class="hljs-variable">objB1</span>;<br>    <span class="hljs-variable">cout</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;objB1.b=&quot;</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-variable">objB1</span>.<span class="hljs-property">b</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-string">&quot;<span class="hljs-char escape_">\n</span>objB1.b1=&quot;</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-variable">objB1</span>.<span class="hljs-property">b1</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-variable">endl</span>;<br>&#125;<br>int <span class="hljs-title function_">main</span>()<br>&#123;<br>    <span class="hljs-title function_">test</span>();<br>&#125;<br>输出的值依次为：<span class="hljs-number">1</span>，<span class="hljs-number">21</span>，<span class="hljs-number">22</span>，<span class="hljs-number">4</span><br>               <span class="hljs-number">11</span>，<span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><p>☆需要注意的是：D的对象在调用b1，b2时,直接调用基类的构造函数，而忽略D的调用。比如：在创建类对象时初始值为（20，05，06，06）时输出为 20，21，22，06。<br>一个类在类体系中可以作为虚基类和非虚基类，这取决于继承方式，与本身的定义无关。</p><h2 id="第九章-虚函数与多态性"><a href="#第九章-虚函数与多态性" class="headerlink" title="第九章  虚函数与多态性"></a>第九章  虚函数与多态性</h2><p>联编：指一个程序模块、代码之间互相关联的过程。<br>多态性：是指一个名字，多种语义；或界面相同，多种实现。重载函数是多态性的一种简单形式。<br>动态联编：指程序联编推迟到运行时进行，所以又称为晚期联编。如：switch 语句和 if 语句是动态联编的例子。虚函数允许函数调用与函数体的联系在运行时才进行。</p><h3 id="9-1-静态联编"><a href="#9-1-静态联编" class="headerlink" title="9.1  静态联编"></a>9.1  静态联编</h3><p>普通成员函数重载可表达为两种形式：</p><ol><li>在一个类说明中重载。例如：<br>void Show ( int , char ) ;void Show ( char * ,float ) ;</li><li>基类的成员函数在派生类重载。有 3 种编译区分方法：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">（<span class="hljs-number">1</span>）根据参数的特征加以区分<br>例如：<span class="hljs-type">void</span> <span class="hljs-keyword">Show</span> ( <span class="hljs-type">int</span> , <span class="hljs-type">char</span> )；与<span class="hljs-type">void</span> <span class="hljs-keyword">Show</span> ( <span class="hljs-type">char</span> * , <span class="hljs-type">float</span> )；不是同一函数，编译能够区分<br>（<span class="hljs-number">2</span>）使用“ :: ”加以区分(类名：：函数名（）)<br>例如：A :: <span class="hljs-keyword">Show</span> ( )；有别于B :: <span class="hljs-keyword">Show</span> ( )；<br>（<span class="hljs-number">3</span>）根据类对象加以区分（根据this指针类型区分<span class="hljs-comment">--&gt;对象名.函数名（））</span><br>例如：Aobj . <span class="hljs-keyword">Show</span> ( )调用A :: <span class="hljs-keyword">Show</span> ( )；Bobj . <span class="hljs-keyword">Show</span> ( )调用B :: <span class="hljs-keyword">Show</span> ( )<br>☆以上方法实际上都是根据类或对象来确定成员函数隐式参数this指针的不同关联类型的，因此重载函数在编译阶段即完成匹配。<br></code></pre></td></tr></table></figure></li></ol><h3 id="9-2-类指针的关系"><a href="#9-2-类指针的关系" class="headerlink" title="9.2  类指针的关系"></a>9.2  类指针的关系</h3><p>概述：<br>基类指针和派生类指针与基类对象和派生类对象4种可能匹配：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">直接用基类指针引用基类对象；（安全）<br>直接用派生类指针引用派生类对象；（安全）<br>用基类指针引用一个派生类对象；<br>用派生类指针引用一个基类对象。 <br></code></pre></td></tr></table></figure><p>我们这一讲主要讲述后两种情况。</p><h4 id="基类指针引用派生类对象"><a href="#基类指针引用派生类对象" class="headerlink" title="基类指针引用派生类对象"></a>基类指针引用派生类对象</h4><p>正如计算机书籍也是书籍一样，基类指针引用派生类对象是安全的。<br>一般情况下，基类指针指向派生类对象时，只能引用基类成员。<br>☆☆☆如果试图引用派生类中特有的成员，则必须通过强制类型转换把基类指针转换成派生类指针，否则会出错。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">大概的使用方式：<br>A    * p <span class="hljs-comment">;// 指向类型 A 的对象的指针</span><br>A    A_obj <span class="hljs-comment">;// 类型 A 的对象</span><br><span class="hljs-keyword">B </span>   <span class="hljs-keyword">B_obj </span><span class="hljs-comment">;// 类型 B 的对象</span><br>p = &amp; A_obj <span class="hljs-comment">;// p 指向类型 A  的对象</span><br>p = &amp; <span class="hljs-keyword">B_obj </span><span class="hljs-comment">;// p 指向类型 B  的对象，它是 A 的派生类</span><br>利用 p，可以通过 <span class="hljs-keyword">B_obj </span>访问所有从 A 类继承的元素<br>☆但不能用 p访问 <span class="hljs-keyword">B </span>类自定义的元素，除非用了显式类型转换（在用指针时前面加一个（派生类类名*）指针）<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">A_class</span><br>&#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">put_name</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span> </span>&#123; <span class="hljs-built_in">strcpy_s</span>(name, s); &#125;<br>      <span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">show_name</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">B_class</span> : <span class="hljs-keyword">public</span>  A_class<br>&#123;<br>    <span class="hljs-type">char</span> phone_num[<span class="hljs-number">20</span>];<br><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">put_phone</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* num)</span> </span>&#123; <span class="hljs-built_in">strcpy_s</span>(phone_num, num); &#125;<br>      <span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">show_phone</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; phone_num &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A_class* A_p;      <span class="hljs-comment">//基类指针</span><br>    A_class  A_obj;    <span class="hljs-comment">//基类对象</span><br>    B_class   B_obj;   <span class="hljs-comment">//派生类对象</span><br>    A_p = &amp;A_obj;      <span class="hljs-comment">//基类指针指向基类对象</span><br>    A_p-&gt;<span class="hljs-built_in">put_name</span>(<span class="hljs-string">&quot;Xiao xiang jun&quot;</span>);   A_p-&gt;<span class="hljs-built_in">show_name</span>();<span class="hljs-comment">//基类指针调用基类成员函数</span><br>    A_p = &amp;B_obj;      <span class="hljs-comment">//基类指针指向派生类对象</span><br>    A_p-&gt;<span class="hljs-built_in">put_name</span>(<span class="hljs-string">&quot;Xie hong jin&quot;</span>);A_p-&gt;<span class="hljs-built_in">show_name</span>()；<span class="hljs-comment">//基类指针调用从基类继承的成员函数</span><br>    B_obj.<span class="hljs-built_in">put_phone</span>(<span class="hljs-string">&quot;13532877395&quot;</span>);                <span class="hljs-comment">//用派生类对象调用派生类成员函数</span><br>    ((B_class*)A_p)-&gt;<span class="hljs-built_in">show_phone</span>();<span class="hljs-comment">//☆对基类指针强制类型转换调用派生类的成员函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="派生类引用基类对象"><a href="#派生类引用基类对象" class="headerlink" title="派生类引用基类对象"></a>派生类引用基类对象</h4><p>派生类指针只有经过强制类型转换之后，才能引用基类对象。<br>两种方法：</p><h5 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h5><p>正常写完其他部分，然后再main函数中创建一个派生类对象和指向它的指针，利用强制类型转换对象&#x2F;指针后，就可以直接调用基类成员函数了。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle">例如：<br><span class="hljs-keyword">int</span> main()<br>&#123;<br>    DateTime dt(<span class="hljs-number">2004</span>,<span class="hljs-number">12</span>,<span class="hljs-number">30</span>,<span class="hljs-number">15</span>,<span class="hljs-number">25</span>,<span class="hljs-number">00</span>);  <span class="hljs-comment">//创建派生类对象并且赋初值</span><br>    DateTime* pdt = &amp;dt;               <span class="hljs-comment">//创建派生类指针指针</span><br>    ((Date)dt).<span class="hljs-keyword">Print</span>();                <span class="hljs-comment">//强制类型转换派生类对象</span><br>    dt.<span class="hljs-keyword">Print</span>();                        <span class="hljs-comment">//对象名直接调用</span><br>    ((Date*)pdt)-&gt;<span class="hljs-keyword">Print</span>();             <span class="hljs-comment">//强制类型转换派生类指针</span><br>    pdt-&gt;<span class="hljs-keyword">Print</span>();                      <span class="hljs-comment">//指针直接调用</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h5><p>在需要用到基类函数的函数体中（（基类类名*）指针）this–&gt;基类函数名（）。<br>例如：(以下是一个派生类函数)</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-literal">void</span> Print()<br>&#123;<br>    <span class="hljs-function"><span class="hljs-params">((<span class="hljs-built_in">Date</span>*)this)</span>-&gt;</span>Print();<br>    cout &lt;&lt; hours &lt;&lt; <span class="hljs-string">&#x27;:&#x27;</span> &lt;&lt; minutes &lt;&lt; <span class="hljs-string">&#x27;:&#x27;</span> &lt;&lt; seconds &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-3-☆虚函数和动态联编"><a href="#9-3-☆虚函数和动态联编" class="headerlink" title="9.3  ☆虚函数和动态联编"></a>9.3  ☆虚函数和动态联编</h3><p>概念：<br>冠以关键字 virtual 的成员函数称为虚函数<br>实现运行时多态的关键首先是要说明虚函数，另外，必须用基类指针调用派生类的不同实现版本<br>（先说明，基类指派生）</p><h4 id="9-3-1-虚函数和基类指针"><a href="#9-3-1-虚函数和基类指针" class="headerlink" title="9.3.1 虚函数和基类指针"></a>9.3.1 虚函数和基类指针</h4><p>☆基类指针虽然获取派生类对象地址，却只能访问派生类从基类继承的成员，没继承的不能用！！！只能显示的调用或者强制类型转换。<br>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:       <span class="hljs-built_in">Base</span>(<span class="hljs-type">char</span> xx) &#123; x = xx; &#125;<br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">who</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base class: &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; &#125;<br><span class="hljs-keyword">protected</span>:    <span class="hljs-type">char</span> x;<br>&#125;;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">First_d</span> : <span class="hljs-keyword">public</span>  Base<br>&#123;<br><span class="hljs-keyword">public</span>:       <span class="hljs-built_in">First_d</span>(<span class="hljs-type">char</span> xx, <span class="hljs-type">char</span> yy) :<span class="hljs-built_in">Base</span>(xx) &#123; y = yy; &#125;<br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">who</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;First derived class: &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; &#125;<br><span class="hljs-keyword">protected</span>:    <span class="hljs-type">char</span> y;<br>&#125;;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Second_d</span> : <span class="hljs-keyword">public</span>  First_d<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Second_d</span>(<span class="hljs-type">char</span> xx, <span class="hljs-type">char</span> yy, <span class="hljs-type">char</span> zz) : <span class="hljs-built_in">First_d</span>(xx, yy) &#123; z = zz; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">who</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Second derived class: &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; &#125;<br><span class="hljs-keyword">protected</span>:    <span class="hljs-type">char</span> z;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Base  <span class="hljs-title">B_obj</span><span class="hljs-params">(<span class="hljs-string">&#x27;A&#x27;</span>)</span></span>;   <span class="hljs-function">First_d <span class="hljs-title">F_obj</span><span class="hljs-params">(<span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>)</span></span>;  <span class="hljs-function">Second_d <span class="hljs-title">S_obj</span><span class="hljs-params">(<span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>)</span></span>;<br>    Base* p;<br>    p = &amp;B_obj;    p-&gt;<span class="hljs-built_in">who</span>();  <span class="hljs-comment">//把基类对象的地址给了指针，指针指向的函数是基类中的</span><br>    p = &amp;F_obj;     p-&gt;<span class="hljs-built_in">who</span>(); <span class="hljs-comment">//把派生类对象的地址给了指针，指针指向的函数是基类中的</span><br>    p = &amp;S_obj;     p-&gt;<span class="hljs-built_in">who</span>(); <span class="hljs-comment">//把派生类对象的地址给了指针，指针指向的函数是基类中的</span><br>    F_obj.<span class="hljs-built_in">who</span>();        <span class="hljs-comment">//显式调用</span><br>    ((Second_d*)p)-&gt;<span class="hljs-built_in">who</span>(); <span class="hljs-comment">//强制类型转换</span><br>&#125;<br>所以输出为：A,T,E.TO,END<br></code></pre></td></tr></table></figure><p>☆☆☆但是其实我们也感觉得到，好麻烦，那怎么办？能不能让指针指向派生类对象时，直接可以调用类对象中的who？因为强制或显式调用真的好麻烦。欸，说来就来，C++提供了一个虚函数解释机制，，可以让基类指针依赖运行时的地址，调用不同类版本的成员函数（装逼一点可以叫它动态性质）<br>☆☆☆此时，我们只需要再基类的who函数前面加一个virtual，这样who函数就会变成一个虚函数，后面的who函数就会默认为虚函数。然后我们就可以达到我们的目的get√。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">☆☆☆虽然这么做很爽，但是还有<span class="hljs-number">4</span>点要注意一下的：<br><span class="hljs-number">1.</span>一旦一个成员被说明成虚函数，则无论派生了多少次，所有界面相同的重载函数都保持虚特性<br><span class="hljs-number">2.</span>虚函数必须是类的成员函数。不能说明为全局函数或者静态成员函数。因为虚函数的动态联编必须再类层次中依靠<span class="hljs-keyword">this</span>指针实现。<br><span class="hljs-number">3.</span>不能将友元说明成虚函数，但虚函数可以是另一个类的友元<br><span class="hljs-number">4.</span>析构函数可以是虚函数，但是构造函数不能是虚函数。<br></code></pre></td></tr></table></figure><h4 id="9-3-2-虚函数的重载特性"><a href="#9-3-2-虚函数的重载特性" class="headerlink" title="9.3.2 虚函数的重载特性"></a>9.3.2 虚函数的重载特性</h4><p>☆重定义基类的虚函数是函数重载的一种特殊的形式，它与一般的函数重载不同，有一个要求（人家都这么方便人了，提点要求怎么了＞﹏＜）。在派生类中重载基类的虚函数要求函数名、返回类型、参数个数、参数类型和顺序完全相同（完全喔，这个要求不高把？）。如果返回值类型不同，一开始就不小心错了，那我算C++错误重载；但是，要是其他的错误，就直接没有虚特性了（手动狗头）。<br>可是，你为什么要提这样的要求呢？因为表面上它们是相同的，但是他们隐含的this指针不同，其关联类型分别是重载它们的派生类。C++的虚特性只负责把基类this指针的关联类型转换成当前指向对象的类类型，而不能改变函数其他参数的性质。</p><h4 id="9-3-3-虚析构函数"><a href="#9-3-3-虚析构函数" class="headerlink" title="9.3.3 虚析构函数"></a>9.3.3 虚析构函数</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">构造函数不能是虚函数。建立一个派生类对象时，必须从类层次的根开始，沿着继承路径逐个调用基类的构造函数<br>析构函数可以是虚的。虚析构函数用于指引 <span class="hljs-keyword">delete</span> 运算符正确析构动态对象 <br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;A::~A() is called.\n&quot;</span>; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;B::~B() is called.\n&quot;</span>; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A* Ap = <span class="hljs-keyword">new</span> B;<br>    B* Bp2 = <span class="hljs-keyword">new</span> B;<br>    cout &lt;&lt; <span class="hljs-string">&quot;delete first object:\n&quot;</span>;<br>    <span class="hljs-keyword">delete</span> Ap;<br>    Ap = <span class="hljs-literal">NULL</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;delete second object:\n&quot;</span>;<br>    <span class="hljs-keyword">delete</span> Bp2;<br>    Bp2 = <span class="hljs-literal">NULL</span>;<br>&#125;<br>在对A的基类指针进行<span class="hljs-keyword">delete</span>时，只析构了基类，没析构派生类。<br>解决方法也很简单，在基类的析构函数前面加一个<span class="hljs-keyword">virtual</span>。<br>啊？那有什么用啊，感觉也不影响程序运行？哈哈，其实没什么用，但是用了没坏处，那就用呗<br></code></pre></td></tr></table></figure><h3 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3><p>基类往往表示一个抽象概念，在一个工作系统中员工employee就是一个基类，可以派生出管理人员啊之类的，不同的人员有不同的工资计算方式。但是专门在基类里面定义一个工资计算函数是没有意义的，所以我们可以把基类的工资计算函数说明为虚函数，仅说明一个公共的界面，而由各自派生类提供各自的实现版本。一个具有纯虚函数的基类叫做抽象类。</p><h4 id="9-4-1-纯虚函数"><a href="#9-4-1-纯虚函数" class="headerlink" title="9.4.1 纯虚函数"></a>9.4.1 纯虚函数</h4><p>纯虚函数是一个在基类中说明的虚函数，在基类中没有定义，要求任何派生类都定义自己的版本<br>纯虚函数为各派生类提供一个公共界面（真的虚，啥都没有）<br>☆纯虚函数说明形式：virtual  类型  函数名（参数表）&#x3D; 0 ;<br>一个具有纯虚函数的基类称为抽象类。<br>☆☆☆若一个类公有继承了一个抽象类，那么它也为抽象类。啊？但是我不想它也抽象怎么办？那就要在派生类中声明它（不带virtual）并且提供它们的定义</p><h4 id="9-4-2-抽象类"><a href="#9-4-2-抽象类" class="headerlink" title="9.4.2 抽象类"></a>9.4.2 抽象类</h4><p>怎么说，抽象类好用吧？但是这哥们要求也很多：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1.抽象类只能用作其他类的基类<br>2.抽象类不能建立类对象<br>3.抽象类不能用作参数类型、函数返回类型或显式类型转换<br></code></pre></td></tr></table></figure><p><img src="/pic/96.png" alt="img"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs arduino">通过指针的方式使纯虚函数在派生类中实现不同版本。<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">figure</span><br>&#123;<br><span class="hljs-keyword">protected</span>: <span class="hljs-type">double</span> x, y;<br><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_dim</span><span class="hljs-params">(<span class="hljs-type">double</span> i, <span class="hljs-type">double</span> j = <span class="hljs-number">0</span>)</span> </span>&#123; x = i;  y = j; &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show_area</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">triangle</span> : <span class="hljs-keyword">public</span> figure<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_area</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Triangle with high &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; and base &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot; has an area of &quot;</span> &lt;&lt; x * <span class="hljs-number">0.5</span> * y &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">square</span> : <span class="hljs-keyword">public</span> figure<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_area</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Square with dimension &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;*&quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot; has an area of &quot;</span> &lt;&lt; x * y &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">circle</span> : <span class="hljs-keyword">public</span> figure<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_area</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Circle with radius &quot;</span> &lt;&lt; x;<br>        cout &lt;&lt; <span class="hljs-string">&quot; has an area of &quot;</span> &lt;&lt; <span class="hljs-number">3.14</span> * x * x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    figure* p;<span class="hljs-comment">// 声明抽象类指针</span><br>    triangle t;   square s;   circle c;<br>    p = &amp;t;<br>    p-&gt;<span class="hljs-built_in">set_dim</span>(<span class="hljs-number">10.0</span>, <span class="hljs-number">5.0</span>); <span class="hljs-comment">// triangle::set_dim()</span><br>    p-&gt;<span class="hljs-built_in">show_area</span>();<br>    p = &amp;s;<br>    p-&gt;<span class="hljs-built_in">set_dim</span>(<span class="hljs-number">10.0</span>, <span class="hljs-number">5.0</span>);<span class="hljs-comment">// square::set_dim()</span><br>    p-&gt;<span class="hljs-built_in">show_area</span>();<br>    p = &amp;c;<br>    p-&gt;<span class="hljs-built_in">set_dim</span>(<span class="hljs-number">9.0</span>);<span class="hljs-comment">// circle::set_dim()</span><br>    p-&gt;<span class="hljs-built_in">show_area</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">或者采用引用的方式实现<br>#include&lt;iostream&gt;<br>using namespace std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span><br>&#123;<br><span class="hljs-keyword">public</span>:      Number(int i) &#123; <span class="hljs-keyword">val</span> = i; &#125;<br>      virtual void Show() = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">protected</span>:  int <span class="hljs-keyword">val</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hex_type</span> : <span class="hljs-type">public</span> <span class="hljs-title">Number</span><br>&#123;<br><span class="hljs-keyword">public</span>:    Hex_type(int i) : Number(i) &#123; &#125;<br>      void Show() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Hexadecimal:&quot;</span> &lt;&lt; hex &lt;&lt; <span class="hljs-keyword">val</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dec_type</span> : <span class="hljs-type">public</span> <span class="hljs-title">Number</span><br>&#123;<br><span class="hljs-keyword">public</span>:    Dec_type(int i) : Number(i) &#123; &#125;<br>      void Show() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Decimal: &quot;</span> &lt;&lt; dec &lt;&lt; <span class="hljs-keyword">val</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Oct_type</span> : <span class="hljs-type">public</span> <span class="hljs-title">Number</span><br>&#123;<br><span class="hljs-keyword">public</span>:    Oct_type(int i) : Number(i) &#123; &#125;<br>      void Show() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Octal: &quot;</span> &lt;&lt; oct &lt;&lt; <span class="hljs-keyword">val</span> &lt;&lt; endl; &#125;<br>&#125;;<br>void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(Number&amp; n)</span></span><span class="hljs-comment">// 抽象类的引用参数</span><br>&#123;<br>    n.Show();<br>&#125;<br>int main()<br>&#123;<br>    Dec_type n1(<span class="hljs-number">50</span>);<br>    <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n1)</span></span>;   <span class="hljs-comment">// Dec_type::Show()</span><br>    Hex_type n2(<span class="hljs-number">50</span>);<br>    <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n2)</span></span>;   <span class="hljs-comment">// Hex_type::Show()</span><br>    Oct_type n3(<span class="hljs-number">50</span>);<br>    <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n3)</span></span>;   <span class="hljs-comment">// Oct_type::Show()</span><br>&#125;<br>哎呀这个地方就是往<span class="hljs-function"><span class="hljs-keyword">fun</span>函数的参数表里面放基类，然后再调用各自类的show。</span><br></code></pre></td></tr></table></figure><h2 id="第十章-模板"><a href="#第十章-模板" class="headerlink" title="第十章  模板"></a>第十章  模板</h2><p>模板把函数或类要处理的数据类型参数化，表现为参数的多态性，称为类属。<br>模板用于表达逻辑结构相同，但具体数据元素类型不同的数据对象的通用行为。</p><h3 id="10-1-什么是模板"><a href="#10-1-什么是模板" class="headerlink" title="10.1  什么是模板"></a>10.1  什么是模板</h3><p>类属 —— 类型参数化，又称参数模板，使得程序（算法）可以从逻辑功能上抽象，把被处理的对象（数据）类型作为参数传递，C++只有函数模板和类模板</p><h3 id="10-2-函数模板"><a href="#10-2-函数模板" class="headerlink" title="10.2  函数模板"></a>10.2  函数模板</h3><p>重载函数通常基于不同的数据类型实现类似的操作；对不同数据类型的操作完全相同，用函数模板实现更为简洁方便</p><h4 id="10-2-1-模板说明"><a href="#10-2-1-模板说明" class="headerlink" title="10.2.1  模板说明"></a>10.2.1  模板说明</h4><p>声明模板中使用的类属参数。形式为 template    &lt; 类型形式参数表 &gt;    </p><h4 id="10-2-2-函数模板与模板函数"><a href="#10-2-2-函数模板与模板函数" class="headerlink" title="10.2.2  函数模板与模板函数"></a>10.2.2  函数模板与模板函数</h4><p>函数模板声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>  &lt; 类型形式参数表 ---&gt;<span class="hljs-keyword">typename</span> T1/<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>&gt;<br>类型  函数名 （ 形式参数表 ）<br>    &#123;   语句序列<br>    &#125;<br></code></pre></td></tr></table></figure><p>函数模板定义由模板说明和函数定义组成<br>模板说明的类属参数必须在函数定义中至少出现一次<br>函数参数表中可以使用类属类型参数，也可以使用一般类型参数 </p><h4 id="10-2-3-重载函数模板"><a href="#10-2-3-重载函数模板" class="headerlink" title="10.2.3  重载函数模板"></a>10.2.3  重载函数模板</h4><p>可以定义同名的函数模板，提供不同的参数和实现；也可以使用其他非模板函数重载。</p><h5 id="函数模板的重载"><a href="#函数模板的重载" class="headerlink" title="函数模板的重载"></a>函数模板的重载</h5><p>当函数参数的类型、个数不相同时所进行的类似操作</p><h5 id="用普通函数重载版本"><a href="#用普通函数重载版本" class="headerlink" title="用普通函数重载版本"></a>用普通函数重载版本</h5><p>对于Max函数来说，当传入的两个参数的类型不一样（int和char可以比较但是版本类型不能提供类型的隐式转换）的时候，需要对函数进行重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span>using namespace std ;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h &gt;</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">Max</span><span class="hljs-params">( <span class="hljs-type">const</span> T a, <span class="hljs-type">const</span> T b )</span>  </span>&#123; <span class="hljs-keyword">return</span> a&gt;b ? a : b ; &#125;<span class="hljs-comment">//模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-comment">//参数个数不同重载</span><br><span class="hljs-function">T <span class="hljs-title">Max</span><span class="hljs-params">( <span class="hljs-type">const</span> T a, <span class="hljs-type">const</span> T b , <span class="hljs-type">const</span> T c)</span></span><br><span class="hljs-function"></span>&#123; T t ;  t = <span class="hljs-built_in">Max</span>(a, b) ;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Max</span> ( t, c ) ;  &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Max</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">int</span> a , <span class="hljs-type">const</span> <span class="hljs-type">char</span> b )</span>  </span>&#123; <span class="hljs-keyword">return</span> a&gt;b ? a : b ; &#125;<span class="hljs-comment">//参数类型不同重载</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">( )</span></span><br><span class="hljs-function"> </span>&#123; cout&lt;&lt; <span class="hljs-string">&quot; Max( 3, &#x27;a&#x27; ) is &quot;</span> &lt;&lt; <span class="hljs-built_in">Max</span>( <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span> ) &lt;&lt; endl ;<br>    cout &lt;&lt; <span class="hljs-string">&quot; Max(9.3, 0.5) is &quot;</span> &lt;&lt; <span class="hljs-built_in">Max</span>(<span class="hljs-number">9.3</span>, <span class="hljs-number">0.5</span>) &lt;&lt; endl ;<br>    cout &lt;&lt; <span class="hljs-string">&quot; Max(9, 5, 23) is &quot;</span> &lt;&lt; <span class="hljs-built_in">Max</span>(<span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">23</span>) &lt;&lt; endl ;<br> &#125;<br></code></pre></td></tr></table></figure><p>执行顺序和匹配约定</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">寻找和使用最符合函数名和参数类型的函数，若找到则调用它；<br>否则，寻找一个函数模板，将其实例化产生一个匹配的模板函数，若找到<br>  则调用它；<br>否则，寻找可以通过类型转换进行参数匹配的重载函数，若找到则调用它<br>如果按以上步骤均未能找到匹配函数，则调用错误。<br>如果调用有多于一个的匹配选择，则调用匹配出现二义性。<br></code></pre></td></tr></table></figure><h3 id="10-3-类模板"><a href="#10-3-类模板" class="headerlink" title="10.3  类模板"></a>10.3  类模板</h3><p>类模板用于实现类所需数据的类型参数化<br>类模板在表示如数组、表、图等数据结构显得特别重要，这些数据结构的表示和算法不受所包含的元素类型的影响</p><h4 id="10-3-1-类模板与模板类"><a href="#10-3-1-类模板与模板类" class="headerlink" title="10.3.1  类模板与模板类"></a>10.3.1  类模板与模板类</h4><p>定义：<br>template    &lt;类型形式参数表—&gt;typename T&gt;<br>  类声明<br>例子：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std ;<br><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> T &gt;<span class="hljs-comment">//这是一个类模板</span><br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Array</span><br>&#123; <span class="hljs-keyword">public</span> :<br>    <span class="hljs-built_in">Array</span> ( <span class="hljs-type">int</span> s ) ;<br>    <span class="hljs-keyword">virtual</span> ~ <span class="hljs-built_in">Array</span> () ;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> T&amp; <span class="hljs-title">Entry</span><span class="hljs-params">( <span class="hljs-type">int</span> index )</span> <span class="hljs-type">const</span> </span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Enter</span><span class="hljs-params">( <span class="hljs-type">int</span> index, <span class="hljs-type">const</span> T &amp; value )</span> </span>;<span class="hljs-comment">//输入的函数模板</span><br>  <span class="hljs-keyword">protected</span> : <span class="hljs-comment">//注意是protected</span><br>    <span class="hljs-type">int</span> size ;<br>    T * element ;<br>&#125; ;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; Array&lt;T&gt;::<span class="hljs-built_in">Array</span>(<span class="hljs-type">int</span> s)<span class="hljs-comment">//下面一坨全都是各种定义。</span><br>  &#123; <span class="hljs-keyword">if</span> ( s &gt; <span class="hljs-number">1</span> ) size = s ;     <span class="hljs-keyword">else</span> size = <span class="hljs-number">1</span> ;<br>     element = <span class="hljs-keyword">new</span> T [ size ] ;<br>  &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">typename</span> T &gt; Array &lt; T &gt; :: ~<span class="hljs-built_in">Array</span>()<br>  &#123; <span class="hljs-keyword">delete</span> [] element ; &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">typename</span> T &gt; <span class="hljs-type">const</span> T&amp; Array &lt; T &gt; :: <span class="hljs-built_in">Entry</span> ( <span class="hljs-type">int</span> index ) <span class="hljs-type">const</span><br>  &#123; <span class="hljs-keyword">return</span>  element [ index ] ; &#125;<br><span class="hljs-keyword">template</span> &lt; <span class="hljs-keyword">typename</span> T &gt; <span class="hljs-type">void</span> Array &lt; T &gt; :: <span class="hljs-built_in">Enter</span>(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> T&amp; value)<br>  &#123; element [ index ] = value ; &#125;<br><span class="hljs-comment">//开始主函数：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; Array &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">IntAry</span>( <span class="hljs-number">5</span> ) ;<span class="hljs-comment">//实例化类模板变成模板类</span><br>   <span class="hljs-type">int</span> i ; <br>   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++ )  IntAry.<span class="hljs-built_in">Enter</span> ( i, i ) ;<br>   cout &lt;&lt; <span class="hljs-string">&quot;Integer Array : \n&quot;</span> ;<br>   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++ )  cout &lt;&lt; IntAry.<span class="hljs-built_in">Entry</span>(i) &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> ;<br>   cout&lt;&lt;endl ;<br>   Array &lt;<span class="hljs-type">double</span>&gt; <span class="hljs-built_in">DouAry</span>( <span class="hljs-number">5</span> ) ;<span class="hljs-comment">//实例化类模板变成模板类</span><br>   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++ )  DouAry.<span class="hljs-built_in">Enter</span> ( i, (i+<span class="hljs-number">1</span>)*<span class="hljs-number">0.35</span> ) ;<br>   cout &lt;&lt; <span class="hljs-string">&quot;Double Array : \n&quot;</span> ;<br>   <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++ )  cout &lt;&lt; DouAry.<span class="hljs-built_in">Entry</span>(i) &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> ;<br>   cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-3-2-类模板作函数参数"><a href="#10-3-2-类模板作函数参数" class="headerlink" title="10.3.2  类模板作函数参数"></a>10.3.2  类模板作函数参数</h4><p>函数的形式参数类型可以是类模板或类模板的引用对应的实际参数是该类模板实例化的模板类对象–&gt;利用函数调用类模板<br>当一个函数拥有类模板参数时，这个函数必定是函数模板 </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">定义了一个用<span class="hljs-keyword">Array</span>作为参数的函数模板<br><span class="hljs-keyword">template</span> &lt; typename T &gt;<br><span class="hljs-type">void</span>  Tfun( const <span class="hljs-keyword">Array</span> &lt;T&gt; &amp; x , <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> )<br>   &#123; cout &lt;&lt; x.Entry( <span class="hljs-keyword">index</span> ) &lt;&lt; endl ; &#125; <br>调用函数模板<br><span class="hljs-keyword">Array</span> &lt;<span class="hljs-type">double</span>&gt; DouAry( <span class="hljs-number">5</span> ) ;//<span class="hljs-keyword">Array</span> &lt;<span class="hljs-type">double</span>&gt;这一动作是初始化；DouAry( <span class="hljs-number">5</span> )调用构造函数，实例化模板类，建立对象 <br>…<br>Tfun(DouAry,<span class="hljs-number">3</span>); //Tfun实例化为模板函数，(DouAry,<span class="hljs-number">3</span>)调用模板函数。<br></code></pre></td></tr></table></figure><h4 id="10-3-3-在类层次中的类模板"><a href="#10-3-3-在类层次中的类模板" class="headerlink" title="10.3.3  在类层次中的类模板"></a>10.3.3  在类层次中的类模板</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">一个类模板在类层次结构中既可以是基类也可以是派生类：<br>·类模板可以从类模板，或从普通类（非模板类）派生；<br>·模板类可以从类模板或从普通类派生。<br>·当一个类模板从普通类派生时，意味着派生类增加了类属参数；<br>·当一个模板类从类模板派生时，意味着派生类继承基类时提供了实例化的类型参<br>数。<br></code></pre></td></tr></table></figure><h4 id="10-3-4-类模板与友元"><a href="#10-3-4-类模板与友元" class="headerlink" title="10.3.4  类模板与友元"></a>10.3.4  类模板与友元</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">在类模板中可以声明各种友元关系<br> 一个函数或函数模板可以类是或类模板的友元<br> 一个类或类模板可以是类或类模板的友元类<br> 声明这种模板之间的友元关系符号比较烦琐<br></code></pre></td></tr></table></figure><h4 id="10-3-5-类模板与static成员"><a href="#10-3-5-类模板与static成员" class="headerlink" title="10.3.5  类模板与static成员"></a>10.3.5  类模板与static成员</h4><p> 从类模板实例化的每个模板类有自己的类模板数据成员，该模板类的所有对象共享一个static数据成员<br> 和非模板类的static数据成员一样，模板类的static数据成员也应该在文件范围定义和初始化<br> 每个模板类有自己的类模板的static数据成员副本</p><h3 id="10-4-标准模板"><a href="#10-4-标准模板" class="headerlink" title="10.4  标准模板"></a>10.4  标准模板</h3><p>标准模板库中有三个组件：容器，迭代器和算法，利用它进行泛编程，可以节省大量的时间和精力。</p><h4 id="10-4-1-容器"><a href="#10-4-1-容器" class="headerlink" title="10.4.1  容器"></a>10.4.1  容器</h4><p>“容器”是数据结构，按某种特定的逻辑关系把数据元素组装起来的数据集。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">分类:<br><span class="hljs-number">1</span>.序列容器<span class="hljs-comment">---提供顺序表的表示和操作</span><br><br></code></pre></td></tr></table></figure><h1 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h1><p> Date(int y, int m, int d) { SetDate(y, m, d); }<br> void SetDate(int y, int m, int d) { year &#x3D; y; month &#x3D; m; day &#x3D; d; }<br> DateTime(int y, int m, int d, int h, int mi, int s) : Date(y, m, d) { SetTime(h, mi, s); }<br>void SetTime(int h, int mi, int s) { hours &#x3D; h;  minutes &#x3D; mi;  seconds &#x3D; s; }</p><p>关于final，final类不可继承，final虚函数不可被重写<br>一般重写的函数后面要加一个override</p><h1 id="全书总结"><a href="#全书总结" class="headerlink" title="全书总结:"></a>全书总结:</h1><h2 id="第六章-类与对象-1"><a href="#第六章-类与对象-1" class="headerlink" title="第六章  类与对象"></a>第六章  类与对象</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span>  <span class="hljs-title class_">A</span>  <br>&#123;<br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//公有段数据</span><br>    A(<span class="hljs-built_in">int</span> x=<span class="hljs-number">0</span>,<span class="hljs-built_in">int</span> y=<span class="hljs-number">0</span>):X(x),Y(y)&#123;&#125;  <span class="hljs-comment">//这是一个构造函数</span><br>    A(<span class="hljs-built_in">int</span> x=<span class="hljs-number">0</span>):X(x)&#123;&#125;  <span class="hljs-comment">//这是一个构造函数的重载</span><br>    A（<span class="hljs-keyword">const</span> A&amp;，<span class="hljs-built_in">int</span>=<span class="hljs-number">1</span>）；<span class="hljs-comment">//这是一个拷贝构造函数，有效的防止了二义性，传值的时候传入对象</span><br>    A(<span class="hljs-built_in">int</span> x,<span class="hljs-built_in">int</span> y)：b(x),y(y)&#123;&#125;;  <span class="hljs-comment">//这是一个类的包含，</span><br>    ~A（）&#123;cout&lt;&lt;<span class="hljs-string">&quot;释放内存空间。&quot;</span>&lt;&lt; endl;&#125;  <span class="hljs-comment">//这是一个析构函数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> M；<span class="hljs-comment">//常数据成员</span><br>    <span class="hljs-keyword">const</span> A a；<span class="hljs-comment">//常对象</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>（）<span class="hljs-keyword">const</span>；<span class="hljs-comment">//常成员函数</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>（）；<span class="hljs-comment">//静态成员函数</span><br>    friend <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>（A*或者A&amp;a，<span class="hljs-built_in">int</span> n）；<span class="hljs-comment">//友元函数 （访问时（&amp;a或者a，1））</span><br>    friend <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>；<span class="hljs-comment">//友元类</span><br><span class="hljs-keyword">protected</span>：<span class="hljs-comment">//保护段数据</span><br>    <br><span class="hljs-keyword">private</span>：<span class="hljs-comment">//私有段数据 </span><br>    <span class="hljs-keyword">static</span> b；<span class="hljs-comment">//静态数据成员</span><br>    B b；<span class="hljs-comment">//类的包含</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>：<br>       B（xx）：b（xx）&#123;&#125;；<span class="hljs-comment">//类的包含</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们第六章差不多就学了这一段内容。我现在来展开说说：<br>public 类内类外可见<br>protected：类内派生类内可见<br>private：只有类内可见<br>this指针：类的成员自带的，告诉编译器，我们用的是哪一个类的内容<br>构造函数和析构函数只能写在公有段，因为对象必须在类说明之外被创建和撤销<br>构造函数：<br>1.一般会带参数初始化数据成员。<br>2.构造函数可以重载，对象会根据参数调用匹配的一个，防止二义性的话可以用拷贝构造函数<br>3.浅复制和深复制（可以对参数进行简单的赋值）深复制就是把原本的函数copy下来，把形参改成对象的形式<br>常成员：<br>常数据成员：初始化后不可修改，带参数的构造函数对常赋值可以让每个不同的常数据成员有不同的初值<br>常对象：使得对象的全部数据成员被约束为只读，不可修改<br>常成员函数：不能修改数据成员。<br>静态成员：<br>1.静态数据成员：由类的各个对象共用<br>2.静态成员函数：没有this指针，只能访问静态数据成员。（他的存在只为她，哭了.jpg）<br>友元：友元可以访问类的所有成员，包括私有成员，非对称非传递。<br>1.友元函数：在那个段声明无所谓，不影响使用。友元函数必须显示的指明要访问的对象，因为它没有this指针。<br>2.友元类：若B类为A类的友元类，则B中的所有函数都是A类中的成员函数。B类可以直接调用A类的数据成员。一般B类没有自己的数据成员，它的存在只是为了对A类进行操作。<br>类的包含：把另一个类抄写进来</p><h2 id="第八章-继承-1"><a href="#第八章-继承-1" class="headerlink" title="第八章  继承"></a>第八章  继承</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>：<br>&#123;<br><span class="hljs-keyword">public</span>：<br>      <span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> i):<span class="hljs-built_in">x</span>(i)&#123;&#125;<span class="hljs-comment">//基类的初始化，即用构造函数初始化数据成员</span><br>      <span class="hljs-type">int</span> X；<br>      <span class="hljs-type">void</span> Y（）；<br>      <span class="hljs-type">int</span> Y（<span class="hljs-type">int</span>）；<br>      <span class="hljs-type">static</span> i;<span class="hljs-comment">//静态数据成员，在A类和D类中都可以进行修改。</span><br><span class="hljs-keyword">private</span>:<br>&#125;;<br>D::i=<span class="hljs-number">0</span>; <span class="hljs-comment">//类外初始化静态成员</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> ：<span class="hljs-keyword">public</span> B，<span class="hljs-keyword">protected</span> C，<span class="hljs-keyword">private</span> D ,<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> E<span class="hljs-comment">//A类公有继承B，保护继承C，私有继承D。省略默认私有，struct默认公有。这里也是多继承.E为虚继承。</span><br>&#123;<br><span class="hljs-keyword">public</span>：<br>       <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> j):<span class="hljs-built_in">h</span>(j),<span class="hljs-built_in">D</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//基类的初始化，这里为基类的成员也初始化了。</span><br>       <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> j):<span class="hljs-built_in">h</span>(j),<span class="hljs-built_in">D</span>(j);<span class="hljs-comment">//基类的初始化，这里的初始化就是有问题的，因为C++先执行基类的构造函数，此时还没有j这个东西，只是为x开辟了一个数据空间，没有初始化。如果一</span><br>                            定要这么用的话，那么在初始化对象时，应该把D的值给初始化了。<br>       D::X  <span class="hljs-comment">//访问声明，虽然在public这个地方声明，但是此这个已经不是原本的数据成员了，原本的已经到了派生类的private里面，这个属于重名的成员</span><br>       D::Y  <span class="hljs-comment">//访问声明，这里相当于把两个同名函数都声明了，然后它们继承下来之后变成了public的；</span><br>       <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Y</span><span class="hljs-params">()</span></span>;<br>       <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Z</span><span class="hljs-params">()</span></span><br><span class="hljs-function">       </span>&#123;<br>        A::Y;<span class="hljs-comment">//在类中调用基类的重名函数;</span><br>       &#125;<br><span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> h;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    D d;<br>    a.X;<span class="hljs-comment">//访问重名数据成员，这里默认调用派生类</span><br>    a.D::X;<span class="hljs-comment">//访问重名数据成员，这里显示的调用了基类的成员；</span><br>    a.A::Y;<span class="hljs-comment">//在类外main函数中调用基类的重名函数；</span><br>&#125;<br></code></pre></td></tr></table></figure><p>公有继承：把public和protected里的东西平移下去<br>保护继承：把基类的protected和private变成protected继承下去<br>私有继承：把public和protected里的东西变成private平移下去<br>访问声明：格式 基类名::成员；<br>1.不允许降低或提升基类成员的可访问性<br>2.此做法将会重载基类中同一段的所有的同名函数<br>3.派生类也有同名函数时不可用(类内用类名调用，类外用对象调用)<br>类内访问静态成员：略。<br>基类的初始化：利用构造函数对基类数据成员初始化<br>多继承和虚继承：<br>只需要在基类的构造函数前加一个virtual，那么构造函数只会执行开头那一次</p><h2 id="第九章-虚函数与多态性-1"><a href="#第九章-虚函数与多态性-1" class="headerlink" title="第九章  虚函数与多态性"></a>第九章  虚函数与多态性</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>       X(<span class="hljs-built_in">int</span>);<br>       X(<span class="hljs-built_in">char</span>);<span class="hljs-comment">//静态联编的同类重载</span><br>       <span class="hljs-function">visual <span class="hljs-keyword">void</span> <span class="hljs-title">print</span>()</span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;Up to Fate&quot;</span>;&#125;<span class="hljs-comment">//定义虚函数，使得基类指针在调用不同的派生类对象时，调用该派生类对象中的print函数，而非只调用基类中的</span><br>       <span class="hljs-function">visual <span class="hljs-keyword">void</span> <span class="hljs-title">J</span>()</span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;XXJ&quot;</span>;&#125;<span class="hljs-comment">//定义虚函数</span><br>       vistual ~A();<span class="hljs-comment">//虚析构函数</span><br>       <span class="hljs-function">visual <span class="hljs-built_in">int</span> <span class="hljs-title">HYH</span> (<span class="hljs-params"> <span class="hljs-built_in">char</span> </span>)</span>=<span class="hljs-number">0</span>;<span class="hljs-comment">//定义HYH为纯虚函数；</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> : <span class="hljs-title">public</span> <span class="hljs-title">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>       X(<span class="hljs-built_in">int</span>);<span class="hljs-comment">//静态联编的派生类重载</span><br>       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">H</span>()</span><br>       &#123;cout&lt;&lt;<span class="hljs-string">&quot;XHJ&quot;</span>&lt;&lt;endl;&#125;<br>       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span>()</span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;Up to Yourself&quot;</span>;&#125;<br>       <span class="hljs-function">visual <span class="hljs-keyword">void</span> <span class="hljs-title">J</span>()</span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;XHJ&quot;</span>;&#125;<span class="hljs-comment">//虚函数的重写(或者叫做重载)</span><br>       <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">HYH</span>(<span class="hljs-params"><span class="hljs-built_in">char</span></span>)</span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;Hallo Everyone,I&#x27;am HYH.&quot;</span>&lt;&lt;endl;&#125;<span class="hljs-comment">//在派生类中定义纯虚函数；</span><br>       ~B();<br><br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    A *h;<span class="hljs-comment">//创建基类指针；</span><br>    B *j;<span class="hljs-comment">//创建派生类指针；</span><br>    A a;<span class="hljs-comment">//创建基类对象；</span><br>    B b;<span class="hljs-comment">//创建派生类对象；</span><br>    h=&amp;a;<span class="hljs-comment">//基类指针指向基类对象</span><br>    h-&gt;X(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>/···)；<span class="hljs-comment">//基类指针引用基类对象</span><br>    h=&amp;b;<span class="hljs-comment">//基类指针指向派生类对象</span><br>    h-&gt;X(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>/···)；<span class="hljs-comment">//指向派生类对象的基类指针引用基类类对象</span><br>    ((B*)h)-&gt;H();<span class="hljs-comment">//指向派生类对象的基类指针引用派生类类对象</span><br>    j=&amp;b;<span class="hljs-comment">//派生类指针指向派生类对象；</span><br>    j-&gt;H();<span class="hljs-comment">//指向派生类的派生列指针引用派生类对象；</span><br>    j=&amp;a;<span class="hljs-comment">//派生类指针指向基类对象；</span><br>    ((A*)j)-&gt;X(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>/···)；<span class="hljs-comment">//指向基类的派生类指针引用基类对象</span><br>    ((A*)a).X(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>/···)；<span class="hljs-comment">//派生类对象通过强制类型转换访问基类对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>静态联编；就是差不多是重载函数的意思；<br>类指针的关系：<br>1.基类指针引用基类对象<br>2.派生类指针指向派生类对象<br>3.基类指针引用派生类对象（强制类型转换）<br>4.派生类指针引用基类对象（强制类型转换）<br>虚函数：让基类指针指向派生类时直接调用派生类的同名函数<br>虚函数的重载（重写）：在虚函数的基础上执行不同的语句；<br>虚析构函数：使得继承了基类的派生类对象在delete时把基类和派生类的析构函数都执行了<br>纯虚函数：给定一个函数的框架，具体的定义在派生类里面完成；<br>抽象类：有虚构函数的类就叫做抽象类，它只能做基类。不能有对象。可以说明指针和引用；</p><h2 id="第十章-模板-1"><a href="#第十章-模板-1" class="headerlink" title="第十章  模板"></a>第十章  模板</h2><p>模板函数：通常基于不同的数据类型实现类似的操作</p>]]></content>
    
    
    <categories>
      
      <category>大学学习(大一下)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学</title>
    <link href="/2024/03/22/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    <url>/2024/03/22/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h1><h2 id="第一章-数理逻辑"><a href="#第一章-数理逻辑" class="headerlink" title="第一章  数理逻辑"></a>第一章  数理逻辑</h2><h3 id="第一节-绪论、命题"><a href="#第一节-绪论、命题" class="headerlink" title="第一节  绪论、命题"></a>第一节  绪论、命题</h3><h4 id="命题：不受时间限制，客观上能够确定真假的陈述句。"><a href="#命题：不受时间限制，客观上能够确定真假的陈述句。" class="headerlink" title="命题：不受时间限制，客观上能够确定真假的陈述句。"></a>命题：不受时间限制，客观上能够确定真假的陈述句。</h4><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>原子命题：不能分解为更简单的陈述句。<br>复合命题：由联结词、标点符号和原子命题复合构成的命题。<br>命题常量：用来表示确定命题的标识符。 例如：P表示“今天下雨。”<br>命题变元：表示任意命题位置标志的命题标识符。例如：P∨┑P， P∧Q。<br>指派：用一个特定命题取代命题变元P称为对P指派。</p><h4 id="联结词：（越往上越优先）"><a href="#联结词：（越往上越优先）" class="headerlink" title="联结词：（越往上越优先）"></a>联结词：（越往上越优先）</h4><pre><code class="hljs">  ┑：否定 ∧：合取            全真才真，一假即假 ∨：（可兼）析取     全假才假，一真即真。不可兼析取为 (P∧┑Q)∨(┑P∧Q)。 -&gt;：条件          只有真的推出假的才算假 &lt;-&gt;：双条件       当且仅当</code></pre><h4 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">用<span class="hljs-selector-tag">A</span>表示你走，用<span class="hljs-selector-tag">B</span>表示我留下。<br><span class="hljs-number">1</span>.当你走，我将留下。<br><span class="hljs-number">2</span>.当且仅当你走，我将留下。<br><span class="hljs-number">3</span>.仅当你走我将留下。<br></code></pre></td></tr></table></figure><h3 id="第二节-真值表、重言式"><a href="#第二节-真值表、重言式" class="headerlink" title="第二节  真值表、重言式"></a>第二节  真值表、重言式</h3><h4 id="命题公式："><a href="#命题公式：" class="headerlink" title="命题公式："></a>命题公式：</h4><p>单个命题变元或常元本身是一个命题公式；</p><h4 id="真值表："><a href="#真值表：" class="headerlink" title="真值表："></a>真值表：</h4><p>在命题公式中，对于分量指派真值的各种可能组合，就确定了这个命题公式的各种真值情况，把它汇列成表。</p><h4 id="变元取值的顺序：（记结论）"><a href="#变元取值的顺序：（记结论）" class="headerlink" title="变元取值的顺序：（记结论）"></a>变元取值的顺序：（记结论）</h4><p>☆按二进制递增或递减。n个命题变元组成的命题公式共有2^n种真值情况。<br>☆由n个命愿变元组成不等价的命题公式的个数为:2^2^n;</p><h4 id="逻辑等价：两个命题公式A和B，对于任意一组真值指派，-A和B的真值都相同，则称A和B是逻辑等价的或等价的。AB"><a href="#逻辑等价：两个命题公式A和B，对于任意一组真值指派，-A和B的真值都相同，则称A和B是逻辑等价的或等价的。AB" class="headerlink" title="逻辑等价：两个命题公式A和B，对于任意一组真值指派， A和B的真值都相同，则称A和B是逻辑等价的或等价的。A&lt;&#x3D;&gt;B"></a>逻辑等价：两个命题公式A和B，对于任意一组真值指派， A和B的真值都相同，则称A和B是逻辑等价的或等价的。A&lt;&#x3D;&gt;B</h4><h4 id="☆命题的定律："><a href="#☆命题的定律：" class="headerlink" title="☆命题的定律："></a>☆命题的定律：</h4><pre><code class="hljs">       结合率  A∧(B∧C)&lt;=&gt;(A∧B)∧C               A∨(B∨C)&lt;=&gt;(A∨B)∨C       分配律  A∧(B∨C)&lt;=&gt;(A∧B)∨(A∧C)                 A∨(B∧C)&lt;=&gt;(A∨B)∧(A∨C)       德摩根律 ┑(A∨B)&lt;=&gt;┑A∧┑B               ┑(A∧B)&lt;=&gt;┑A∨┑B       ☆蕴含等值式 A-&gt;B&lt;=&gt;┑A∨B       其他:P&lt;-&gt;Q&lt;=&gt;（P∧Q）∨（┑P∧┑Q）  P&lt;-&gt; Q&lt;=&gt;（P→Q）∧（Q→P ）       重言式、永真式   P∨┑P=1       矛盾式、永假式   P∧┑P=0</code></pre><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-number">1</span>.判断  ┑<span class="hljs-keyword">P</span>∧（<span class="hljs-keyword">P</span>∨Q）→q的真值<br><span class="hljs-number">2</span>.验证（<span class="hljs-keyword">P</span>∨Q）→r  &lt;=&gt;（<span class="hljs-keyword">P</span>→r）∧（Q→r ）<br></code></pre></td></tr></table></figure><h3 id="第三节-蕴含式、其他联结词"><a href="#第三节-蕴含式、其他联结词" class="headerlink" title="第三节  蕴含式、其他联结词"></a>第三节  蕴含式、其他联结词</h3><h4 id="蕴含式"><a href="#蕴含式" class="headerlink" title="蕴含式"></a>蕴含式</h4><p>定义：<br>当仅当P-&gt;Q是一个重言式时，我们称“ P 蕴含 Q ”，并记作 P&#x3D;&gt;Q(Q比P大)<br>证明方法：（一般用第一种,第四节会提及）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1、假设前提为真，往证结论为真；<br>2、假设结论为假，往证前提为假，即反证法<br></code></pre></td></tr></table></figure><p>性质：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-number">1.</span>蕴含关系可传递<br><span class="hljs-number">2.</span>两个蕴含式结论的合并：A=&gt;B，A=&gt;C，得到A=&gt;B∧C；<br><span class="hljs-number">3.</span>两个蕴含式前提的合并: B=&gt;A，C=&gt;A，得到B∨C=&gt;A;<br></code></pre></td></tr></table></figure><h4 id="其他联结词"><a href="#其他联结词" class="headerlink" title="其他联结词"></a>其他联结词</h4><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tp">V上面加一杠为不可兼析取<br>↑与非  <span class="hljs-keyword">P</span>↑Q &lt;=&gt; ┑(<span class="hljs-keyword">P</span>∧Q)<br>↓或非  <span class="hljs-keyword">P</span>↓Q &lt;=&gt; ┑(<span class="hljs-keyword">P</span>∨Q)<br></code></pre></td></tr></table></figure><h4 id="最小联结词组"><a href="#最小联结词组" class="headerlink" title="最小联结词组"></a>最小联结词组</h4><p>冗余联结词：<br>在一个联结词的集合中，如果一个联结词可以由集合中的其他联结词定义，否则称为独立联结词。<br>最小联结词组：<br>既能表示任意真值函数（不少），又不含冗余联结词（不多）的联结词集合称为最小联结词组（极小全功能集）。<br>☆以下联结词集合是最小联结词组：<br><img src="/pic/70.png" alt="最小联结词组"></p><h3 id="第四节-对偶与范式"><a href="#第四节-对偶与范式" class="headerlink" title="第四节  对偶与范式"></a>第四节  对偶与范式</h3><h4 id="对偶式"><a href="#对偶式" class="headerlink" title="对偶式"></a>对偶式</h4><p>定义：<br>在给定的命题公式A中，将联结词∧换成∨，∨换成∧，特殊变元 F 和 T 互换，所得公式A* 称为A的对偶式。<br>定理：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>.设A和A*是对偶式，<span class="hljs-built_in">P1</span>,<span class="hljs-built_in">P2</span>,…,Pn 是出现在A和A*中的原子变元，则<br>┑A(<span class="hljs-built_in">P1</span>,<span class="hljs-built_in">P2</span>,…,Pn) &lt;=&gt;A*(┑<span class="hljs-built_in">P1</span>, ┑<span class="hljs-built_in">P2</span>,…, ┑Pn)<br>A (┑<span class="hljs-built_in">P1</span>, ┑<span class="hljs-built_in">P2</span>,…, ┑Pn) &lt;=&gt; ┑ A* (<span class="hljs-built_in">P1</span>,<span class="hljs-built_in">P2</span>,…,Pn)<br><span class="hljs-number">2</span>.设<span class="hljs-built_in">P1</span>,<span class="hljs-built_in">P2</span>,…,Pn 是所有出现在命题公式A和B中的原子变元，如果A&lt;=&gt;B，则A*&lt;=&gt;B*。<br><span class="hljs-number">3</span>.A&lt;=&gt;T 当仅当  A*&lt;=&gt;F  <br></code></pre></td></tr></table></figure><h4 id="☆利用对偶式求命题的非：（定理一）"><a href="#☆利用对偶式求命题的非：（定理一）" class="headerlink" title="☆利用对偶式求命题的非：（定理一）"></a>☆利用对偶式求命题的非：（定理一）</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>.消去其他逻辑运算符，只留下┑、∧、∨（↑、↓）<br><span class="hljs-number">2</span>.用括号表示优先级<br><span class="hljs-number">3</span>.把 <span class="hljs-selector-tag">A</span> 变为 <span class="hljs-selector-tag">A</span>*  (∧∨互换、F T互换、↓↑互换)<br><span class="hljs-number">4</span>.所有变元Pi用┓Pi代入，得到┓<span class="hljs-selector-tag">A</span><br></code></pre></td></tr></table></figure><h4 id="例题：-1"><a href="#例题：-1" class="headerlink" title="例题："></a>例题：</h4><p>A&#x3D;&gt;B,则A*&#x3D;&gt;B*正确吗</p><h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><p>定义：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>.合取范式：形式为A1∧A2∧……∧An的命题公式，其中Ai为命题变元或其否定所组成的析取式。例：(┑<span class="hljs-selector-tag">P</span>∨<span class="hljs-selector-tag">Q</span>)∧R∧(┑<span class="hljs-selector-tag">Q</span>∨┑R) <br><span class="hljs-number">2</span>.析取范式：形式为A1∨A2∨……∨An的命题公式，其中Ai为命题变元或其否定所组成的合取式。例：┑<span class="hljs-selector-tag">A</span>∨┑<span class="hljs-selector-tag">B</span>∨(<span class="hljs-selector-tag">A</span>∧<span class="hljs-selector-tag">B</span>) <br><span class="hljs-number">3</span>.主析取(合取)范式：对于给定的命题公式，一个仅由最小(大)项的析取(合取)所组成的等价公式，称为该命题公式的主析(合取)取范式。<br></code></pre></td></tr></table></figure><p>定理：在真值表中，一个公式的真值为T(F)的指派所对应的最小(大)项的析取(合取)，即为该公式的主析取(合取)范式。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl">例题：<br><span class="hljs-number">1</span>.求(<span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">q</span>)&lt;-&gt;</span>r的合取范式与析取范式,主析取范式与主析取范式<br></code></pre></td></tr></table></figure><h4 id="最大项-最小项"><a href="#最大项-最小项" class="headerlink" title="最大项 最小项"></a>最大项 最小项</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>.(最)小项：n个命题变元的合取式，每个变元或其否定必需有一个且只有一个出现。例如：(<span class="hljs-selector-tag">A</span>∧┑<span class="hljs-selector-tag">B</span>)、(┑<span class="hljs-selector-tag">P</span>∧<span class="hljs-selector-tag">Q</span>∧R) <br><span class="hljs-number">2</span>.(最)大项：n个命题变元的析取式，每个变元或其否定必需有一个且只有一个出现。<br>例如：(<span class="hljs-selector-tag">A</span>∨┑<span class="hljs-selector-tag">B</span>)、(┑<span class="hljs-selector-tag">P</span>∨<span class="hljs-selector-tag">Q</span>∨R) <br>☆（结论）n个命题变元共有几个最大(小)项？ 分别有<span class="hljs-number">2</span>^n个最大项和最小项<br></code></pre></td></tr></table></figure><h3 id="第五节-演绎与命题函数"><a href="#第五节-演绎与命题函数" class="headerlink" title="第五节  演绎与命题函数"></a>第五节  演绎与命题函数</h3><h4 id="演绎："><a href="#演绎：" class="headerlink" title="演绎："></a>演绎：</h4><p>定义：<br>设S是一个命题公式的集合(前提集合)。从S推出公式G的一个演绎是公式的一个有限序列：G1, G2, …, Gk。其中，Gi或者是S，或者是某些 Gj(j&lt; i)的逻辑结果。并且 Gk就是G。我们称公式G为此演绎的逻辑结果，或称从S演绎出G。有时也记为S&#x3D;&gt;G。<br>证明：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">若给出前提集合S<span class="hljs-operator">=</span>【G1 ，…，Gk】，公式G，证明S<span class="hljs-operator">=</span>&gt;G有如下两种方法：<br><span class="hljs-number">1</span>.G1∧ …∧ Gk <span class="hljs-operator">=</span>&gt;G <br><span class="hljs-number">2</span>. 形式演绎法<br></code></pre></td></tr></table></figure><h4 id="形式演绎法："><a href="#形式演绎法：" class="headerlink" title="形式演绎法："></a>形式演绎法：</h4><p>根据一些基本等价式和基本蕴涵式，从S出发，演绎出G。<br>在演绎过程中遵循以下三条规则：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">P</span>规则: 可随便使用前提。（抄前提）<br><span class="hljs-selector-tag">T</span>规则:可随便使用前面演绎出的某些公式的逻辑结果。 （抄自己的结果）<br><span class="hljs-selector-tag">CP</span>规则: 如果需要演绎出的公式是<span class="hljs-selector-tag">P</span><span class="hljs-selector-tag">-</span>&gt;<span class="hljs-selector-tag">Q</span>的形式，则我们可将<span class="hljs-selector-tag">P</span>做为附加前提使用，而力图去演绎出<span class="hljs-selector-tag">Q</span>。<br></code></pre></td></tr></table></figure><h5 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h5><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">1.</span>证明【(P∨Q)，(P-&gt;R)，(Q-&gt;S)】=&gt;S∨R<br><span class="hljs-number">2.</span>【P-&gt;(Q-&gt;S),┑R∨P,Q】=&gt;R-&gt;S<br><span class="hljs-number">3.</span>A,B,C,D四人参加考试后，有人问它们，谁的成绩最好。A说“不是我”，B说“是D”，C说“是 B”，D说“不是我”。四人的回答只有一人符合实际，问是谁的成绩最好?只有一人成绩最好的是谁?(反证法推矛盾)<br><span class="hljs-number">4.</span>【R-&gt;┑Q,R∨S,S-&gt;┑Q,P-&gt;Q】=&gt;┑P（两种方法）<br><span class="hljs-number">5.</span>【A-&gt;<span class="hljs-function"><span class="hljs-params">(b-&gt;C)</span>,<span class="hljs-params">(C∧D)</span>-&gt;</span>E,┑F-&gt;(D∧┑E)】=&gt;A-&gt;(B-&gt;F)<br></code></pre></td></tr></table></figure><h4 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h4><p>定义：可以独立存在的物体叫个体，用于刻划个体的性质或关系的叫谓词<br>表示法：用大写字母表示谓词，用小写字母表示个体。<br>一元谓词表达了个体的性质；多元谓词表达了多个个体之间的关系。<br>例如：A表示“是大学生”； B表示“小于”。a表示“张山”；A(a)表示张山是大学生；B(b,c)表示“b小于c”；B(c,b)表示“c小于b”</p><h4 id="谓词公式的等价"><a href="#谓词公式的等价" class="headerlink" title="谓词公式的等价"></a>谓词公式的等价</h4><p>两个谓词公式A和B，若它们有共同的个体域E，且对A和B的任意一组变元进行赋值，所得的命题真值相同，则称谓词公式A和B在E上是等价的，记作A&lt;&#x3D;&gt;B<br>谓词公式与个体域的关系：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">谓词公式<span class="hljs-selector-tag">A</span>在个体域E上的所有赋值都为真，则称谓词公式<span class="hljs-selector-tag">A</span>在E上是有效的（永真的）<br>谓词公式<span class="hljs-selector-tag">A</span>在个体域E上的所有赋值都为假，则称谓词公式<span class="hljs-selector-tag">A</span>在E上是不可满足的（永假的）<br>谓词公式<span class="hljs-selector-tag">A</span>在个体域E上的至少有一组赋值为真，则称谓词公式<span class="hljs-selector-tag">A</span>在E上是可满足的<br></code></pre></td></tr></table></figure><h4 id="谓词填式"><a href="#谓词填式" class="headerlink" title="谓词填式"></a>谓词填式</h4><p>定义：谓词字母后面填上客体所得的式子叫谓词填式。<br>谓词与命题的关系：单独一个谓词不是完整命题，完整的客体和谓词字母两部分才成为一个命题。</p><h4 id="命题函数"><a href="#命题函数" class="headerlink" title="命题函数"></a>命题函数</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">简单命题函数：<br>由一个谓词，一些客体变元组成的表达式称为简单命题函数。例如 <span class="hljs-selector-tag">A</span>(x)、<span class="hljs-selector-tag">B</span>(x,y)<br>复合命题函数：<br>由一个或多个命题函数以及逻辑联结词组合而成的表达式称为复合命题函数。例如 ┑<span class="hljs-selector-tag">A</span>(x)、<span class="hljs-selector-tag">A</span>(x)-&gt;┑<span class="hljs-selector-tag">B</span>(x,y)<br></code></pre></td></tr></table></figure><p>谓词与命题函数的关系：<br>n元谓词是n个客体变量的命题函数，命题函数不是命题，当客体变元取特定值时，命题函数才构成命题；命题是0元谓词；<br><img src="/pic/56.png" alt="谓词、谓词填式、命题函数的区别"></p><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">全称量词∀<span class="hljs-keyword">x</span>，对所有的 <span class="hljs-keyword">x</span> <br>存在量词∃<span class="hljs-keyword">x</span>，存在一些 <span class="hljs-keyword">x</span><br></code></pre></td></tr></table></figure><p>二者在翻译时的区别：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">M</span>(x)表示x是人，<span class="hljs-built_in">H</span>(x)表示x要呼吸<br>有些人要呼吸：(∃x)(M(x)∧<span class="hljs-built_in">H</span>(x))<br>所有人要呼吸：(∀x)(M(x)-&gt;<span class="hljs-built_in">H</span>(x))<br></code></pre></td></tr></table></figure><h4 id="谓词翻译与个体域"><a href="#谓词翻译与个体域" class="headerlink" title="谓词翻译与个体域"></a>谓词翻译与个体域</h4><p>如果没有给定个体域，则要引入特性谓词<br>例如：所有正实数均可开平方。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">R</span><span class="hljs-params">(x)</span></span>：表示x是实数；<br><span class="hljs-function"><span class="hljs-title">G</span><span class="hljs-params">(x)</span></span>：表示x是正数；<br><span class="hljs-function"><span class="hljs-title">B</span><span class="hljs-params">(x,y)</span></span>：表示x大于y；<br><span class="hljs-function"><span class="hljs-title">S</span><span class="hljs-params">(x)</span></span>：表示x可开平方。<br>当个体域是正实数时：∀<span class="hljs-built_in">xS</span>(x)<br>当个体域是实数时：∀<span class="hljs-built_in">x</span>(<span class="hljs-built_in">G</span>(x)∀<span class="hljs-built_in">S</span>(x))或： ∀<span class="hljs-built_in">x</span>(<span class="hljs-built_in">B</span>(x,<span class="hljs-number">0</span>)-&gt;<span class="hljs-built_in">S</span>(x))<br>当个体域是全体时： ∀<span class="hljs-built_in">x</span>(<span class="hljs-built_in">R</span>(x)∧<span class="hljs-built_in">B</span>(x,<span class="hljs-number">0</span>)-&gt;<span class="hljs-built_in">S</span>(x))<br></code></pre></td></tr></table></figure><h4 id="练习题：-1"><a href="#练习题：-1" class="headerlink" title="练习题："></a>练习题：</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">用P<span class="hljs-comment">(x)</span>表示x来上课，用Q<span class="hljs-comment">(y)</span>表示y是好学生,请用带量词的谓词公式表示以下句子:<br><span class="hljs-comment">(1)</span>来上课的学生都是好学生:<br><span class="hljs-comment">(2)</span>不来上课的学生都不是好学生:<br><span class="hljs-comment">(3)</span>并不是所有好学生都来上课:<br><span class="hljs-comment">(4)</span>好学生不一定都来上课:<br><span class="hljs-comment">(5)</span>所有的好学生都来上课:<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span><span class="hljs-comment">(∀x)</span><span class="hljs-comment">(P(x)</span>→Q<span class="hljs-comment">(x)</span>)<br><span class="hljs-comment">(2)</span><span class="hljs-comment">(∀x)</span><span class="hljs-comment">(¬P(X)</span> →¬Q<span class="hljs-comment">(x)</span>)<br><span class="hljs-comment">(3)</span> ¬<span class="hljs-comment">((∃x)</span>Q<span class="hljs-comment">(x)</span>-&gt;P<span class="hljs-comment">(x)</span>)<br><span class="hljs-comment">(4)</span><span class="hljs-comment">(∃x)</span><span class="hljs-comment">(Q(x)</span>∧P<span class="hljs-comment">(x)</span>)<br><span class="hljs-comment">(5)</span><span class="hljs-comment">(∀x)</span><span class="hljs-comment">(Q(x)</span>→p<span class="hljs-comment">(x)</span>)<br></code></pre></td></tr></table></figure><h3 id="第六节-变元的约束，谓词的等价式与蕴含式"><a href="#第六节-变元的约束，谓词的等价式与蕴含式" class="headerlink" title="第六节  变元的约束，谓词的等价式与蕴含式"></a>第六节  变元的约束，谓词的等价式与蕴含式</h3><h4 id="变元的辖域"><a href="#变元的辖域" class="headerlink" title="变元的辖域"></a>变元的辖域</h4><p>量词后面紧跟的变元在谓词公式中起作用的范围，叫该变元的辖域（或叫作用域）<br>约束变元：<br>被量词修饰的变元称为约束变元，约束变元在作用域中的每次出现叫约束出现<br>自由变元：<br>没被量词修饰的变元称为自由变元，自由变元在谓词公式中的出现叫自由出现</p><h4 id="约束变元的讨论："><a href="#约束变元的讨论：" class="headerlink" title="约束变元的讨论："></a>约束变元的讨论：</h4><p>n元谓词P(x1,x2,…,xn)具有 n 个相互独立的自由变元，若对其中的 k 个变元进行约束，则成为 (n-k) 元谓词。若谓词公式中没有自由变元，则谓词公式成为一个命题。<br>(∃x)(∀y)P(x,y,z)是一元谓词<br>(∃y)P(x,y,z)是二元谓词</p><h4 id="约束变元的换名："><a href="#约束变元的换名：" class="headerlink" title="约束变元的换名："></a>约束变元的换名：</h4><p>(∀x)P(x)与(∀y)P(y)意义相同，故可对约束变元进行换名；</p><h4 id="有限域中消去量词"><a href="#有限域中消去量词" class="headerlink" title="有限域中消去量词"></a>有限域中消去量词</h4><p>若x的个体域是有限集【a1,a2,…,an】，则有：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(∃x)</span>A<span class="hljs-comment">(x)</span> &lt;=&gt; A<span class="hljs-comment">(a1)</span>∧A<span class="hljs-comment">(a2)</span>∧…∧A<span class="hljs-comment">(an)</span><br><span class="hljs-comment">(∀x)</span>A<span class="hljs-comment">(x)</span> &lt;=&gt; A<span class="hljs-comment">(a1)</span>∨A<span class="hljs-comment">(a2)</span>∨…∨A<span class="hljs-comment">(an)</span><br></code></pre></td></tr></table></figure><p>量词的不同出现顺序有不同的意义：(∃x)(∀y)P(x,y)不同于(∀y)(∃x)P(x,y) </p><h4 id="☆量词与”┑”的关系"><a href="#☆量词与”┑”的关系" class="headerlink" title="☆量词与”┑”的关系"></a>☆量词与”┑”的关系</h4><p>☆☆☆  ┑∀&lt;&#x3D;&gt;∃┑   ;┑∃&lt;&#x3D;&gt;∀┑</p><h4 id="☆量词作用域的变化"><a href="#☆量词作用域的变化" class="headerlink" title="☆量词作用域的变化"></a>☆量词作用域的变化</h4><p>在谓词公式中，可以将不含约束变元的命题任意移至量词的作用域之内或之外。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(∀x)</span><span class="hljs-comment">(A(X)</span>∧B<span class="hljs-comment">(X)</span>) &lt;=&gt; <span class="hljs-comment">(∀x)</span> A<span class="hljs-comment">(X)</span>∧<span class="hljs-comment">(∀x)</span> B<span class="hljs-comment">(X)</span><br><span class="hljs-comment">(∃x)</span><span class="hljs-comment">(A(X)</span>∨B<span class="hljs-comment">(X)</span>) &lt;=&gt; <span class="hljs-comment">(∃x)</span> A<span class="hljs-comment">(X)</span>∨<span class="hljs-comment">(∃x)</span> B<span class="hljs-comment">(X)</span><br>区分：<br><span class="hljs-comment">(∃x)</span><span class="hljs-comment">(A(X)</span>∧B<span class="hljs-comment">(X)</span>) =&gt; <span class="hljs-comment">(∃x)</span> A<span class="hljs-comment">(X)</span>∧<span class="hljs-comment">(∃x)</span> B<span class="hljs-comment">(X)</span><br><span class="hljs-comment">(∀x)</span> A<span class="hljs-comment">(X)</span>∨<span class="hljs-comment">(∀x)</span> B<span class="hljs-comment">(X)</span> =&gt;<span class="hljs-comment">(∀x)</span> <span class="hljs-comment">(A(X)</span>∨B<span class="hljs-comment">(X)</span>)<br></code></pre></td></tr></table></figure><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>.用L(x,y)表示x喜欢y，用<span class="hljs-selector-tag">P</span>(<span class="hljs-selector-tag">a</span>)表示<span class="hljs-selector-tag">a</span>是人，<span class="hljs-selector-tag">B</span>(<span class="hljs-selector-tag">a</span>)表示<span class="hljs-selector-tag">a</span>是书，请用带量词的谓词公式表示以下句子:<br>(<span class="hljs-number">1</span>)每个人都有自己喜欢的一本书:<br>(<span class="hljs-number">2</span>)所有人都喜欢某本书:<br><span class="hljs-number">2</span>.论域是质数集，<span class="hljs-built_in">B</span>(x,y)表示x比y大。表示“不存在最大的质数”的谓词公式是:<br></code></pre></td></tr></table></figure><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">1.</span><br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)(∀x)(P(x)-&gt;(∃y)(B(y)∧L(x,y)))</span></span><br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>)(∃y)(B(y)∧((∀x)(P(x)-&gt;L(x,y))))</span></span><br><span class="hljs-function">2.</span><br><span class="hljs-function">┑<span class="hljs-params">((∃x)(∀yB(x,y)))</span></span><br></code></pre></td></tr></table></figure><h3 id="第七节-前束范式"><a href="#第七节-前束范式" class="headerlink" title="第七节  前束范式"></a>第七节  前束范式</h3><p>定义：<br>一个谓词公式，如果量词都在整个式子的前头，其作用域延伸到整个谓词公式的末尾，这样的谓词公式叫前束范式。<br>定理：<br>任意一个谓词公式，都有一个与之等价的前束范式。</p><h4 id="转化的步骤："><a href="#转化的步骤：" class="headerlink" title="转化的步骤："></a>转化的步骤：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">1.取消多余的量词<br>2.换名<br>3.消去条件、双条件联结词<br>4.将┑ 深入<br>5.将量词移至左边<br></code></pre></td></tr></table></figure><h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1.</span>把公式<span class="hljs-comment">(∀x)</span><span class="hljs-comment">(P(x)</span>)→<span class="hljs-comment">(ヨx)</span>Q<span class="hljs-comment">(x)</span>转化为前束范式。<br><span class="hljs-number">2.</span>化公式<span class="hljs-comment">(∀x)</span><span class="hljs-comment">(∀y)</span><span class="hljs-comment">(((ヨz)</span>P<span class="hljs-comment">(x,z)</span>∧P<span class="hljs-comment">(y,z)</span>))-&gt;<span class="hljs-comment">(ヨu)</span><span class="hljs-comment">(Q(x,y,u)</span>)化为前束范式<br><span class="hljs-number">3.</span>设I是如下一个解释：  D=【<span class="hljs-number">2</span>,<span class="hljs-number">3</span>】<br>F<span class="hljs-comment">(2)</span>  F<span class="hljs-comment">(3)</span>  P<span class="hljs-comment">(2)</span>  P<span class="hljs-comment">(3)</span>  Q<span class="hljs-comment">(2,2)</span>  Q<span class="hljs-comment">(2,3)</span>  Q<span class="hljs-comment">(3,2)</span>  Q<span class="hljs-comment">(3,3)</span><br><span class="hljs-number">3</span>     <span class="hljs-number">2</span>       <span class="hljs-number">0</span>    <span class="hljs-number">1</span>      <span class="hljs-number">1</span>        <span class="hljs-number">1</span>      <span class="hljs-number">0</span>       <span class="hljs-number">1</span><br>求∀xヨy（P<span class="hljs-comment">(x)</span>∧Q（F（x），y））的真值。<br><span class="hljs-number">4.</span>证明：ヨx<span class="hljs-comment">(F(x)</span>-&gt;G<span class="hljs-comment">(x)</span>) &lt;=&gt; ∀yF<span class="hljs-comment">(y)</span> -&gt;ヨzG<span class="hljs-comment">(z)</span><br><span class="hljs-number">5.</span>L<span class="hljs-comment">(x,y)</span>表示y是x的先驱数，H<span class="hljs-comment">(x,y)</span>表示y是x的后继数，F<span class="hljs-comment">(x)</span>表示x是自然数，请用带量词的谓词公式表示以下句子：<br><span class="hljs-number">1</span>）有的自然数无先驱数：<br><span class="hljs-number">2</span>） 每个自然数都有后继数：<br><span class="hljs-number">6.</span><span class="hljs-comment">(∀x)</span><span class="hljs-comment">(ヨy)</span><span class="hljs-comment">(P(x)</span>∧Q<span class="hljs-comment">(y)</span>)   -------&gt;谁靠近就先化简谁<br></code></pre></td></tr></table></figure><h4 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h4><p><img src="/pic/60.png" alt="前束范式答案1"><br><img src="/pic/61.png" alt="前束范式答案2"><br><img src="/pic/62.png" alt="前束范式答案3（解法一）"><br><img src="/pic/63.png" alt="前束范式答案3（解法二）"><br><img src="/pic/64.png" alt="前束范式答案4"><br><img src="/pic/65.png" alt="前束范式答案5"><br><img src="/pic/66.jpg" alt="前束范式答案6"></p><h2 id="第二章-集合论"><a href="#第二章-集合论" class="headerlink" title="第二章 集合论"></a>第二章 集合论</h2><h3 id="第一节-集合的运算"><a href="#第一节-集合的运算" class="headerlink" title="第一节  集合的运算"></a>第一节  集合的运算</h3><p>定义：集合是不能精确定义的基本概念，一般用大写字母表示集合，用小写字母表示元素。<br>集合与元素的关系：x∈A 或 x∉A<br>集合元素可以是离散型数据（如整型、逻辑型、枚举型等），也可以是非离散型数据（如实型）。有限集一定是离散型数据，无限集可能是离散型，也可能是非离散型的数据。本书中默认：自然数集从0开始<br>简单过一遍概念：<br><img src="/pic/57.png" alt="子集、真子集、空集、全集定义"><br><img src="/pic/58.png" alt="集合的相等"><br><img src="/pic/59.png" alt="集合运算"><br>空集的性质：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1.空集是一切集合的子集。<br>2.空集是惟一的。<br>3.空集是任何集合的幂集的元素。<br>4.空集的幂集不是空集。<br></code></pre></td></tr></table></figure><p>☆φ⊆【φ】；φ∈【φ】</p><h4 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h4><p>定义：给定集合A，由集合A的所有子集为元素组成的集合，称为集合A的幂集。</p><h4 id="补集"><a href="#补集" class="headerlink" title="补集"></a>补集</h4><p>~A&#x3D;E-A</p><h4 id="集合运算的性质："><a href="#集合运算的性质：" class="headerlink" title="集合运算的性质："></a>集合运算的性质：</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs gcode">E = ~φ= A∪E = A∪~A <br>φ= ~E = A∩φ=A∩~A= A⊕A = A - A<br>A = A∩A = A∩E= A∪A = A∪φ= A⊕φ= ~ <span class="hljs-comment">(~A)</span><br>交换律和结合律只有减法不满足，其他的都可以<br>注意：A - B ≠ B - A /<span class="hljs-comment">(A - B)</span> - C ≠ A - <span class="hljs-comment">( B - C)</span> <br>☆分配律：<br>A∩<span class="hljs-comment">(B∪C)</span> = <span class="hljs-comment">(A∩B)</span>∪<span class="hljs-comment">(A∩C)</span><br>A∪<span class="hljs-comment">(B∩C)</span> = <span class="hljs-comment">(A∪B)</span>∩<span class="hljs-comment">(A∪C)</span><br>A∩<span class="hljs-comment">(B - C)</span>= <span class="hljs-comment">(A∩B)</span> - <span class="hljs-comment">(A∩C)</span>  <br>A∩<span class="hljs-comment">(B⊕C)</span> = <span class="hljs-comment">( A∩B)</span>⊕<span class="hljs-comment">(A∩C)</span><br>但不能：A∪<span class="hljs-comment">(B - C )</span> ≠ <span class="hljs-comment">(A∪B)</span> - <span class="hljs-comment">(A∪C)</span>  <br>但：A∪<span class="hljs-comment">(B⊕C)</span> ≠ <span class="hljs-comment">(A∪B)</span>⊕<span class="hljs-comment">(A∪C)</span><br>摩根律：<br>~ <span class="hljs-comment">(A∪B)</span> =  ~A∩ ~B <br>~ <span class="hljs-comment">(A∩B)</span> =  ~A∪ ~B<br>吸收律：<br>A∪<span class="hljs-comment">(A∩B)</span> = A = A∩<span class="hljs-comment">(A∪B)</span><br>其他：<br>A∩B ⊆A ⊆ A∪B<br>A∩B ⊆ B ⊆ A∪B<br>交集的补集=补集的交集<br>☆☆☆A - B = A∩ ~B = A - <span class="hljs-comment">(A∩B)</span><br></code></pre></td></tr></table></figure><h5 id="练习（期末会有证明相等证明，一般会利用性质证明的方法多）"><a href="#练习（期末会有证明相等证明，一般会利用性质证明的方法多）" class="headerlink" title="练习（期末会有证明相等证明，一般会利用性质证明的方法多）"></a>练习（期末会有证明相等证明，一般会利用性质证明的方法多）</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1.证明<span class="hljs-attribute">A</span>=B，当且仅当A⊕B=φ。（双向证明）<br>2.已知ABC是集合，而且A⊕<span class="hljs-attribute">B</span>=A⊕C，是否一定有B=C （两边同时⊕A，利用结合律做）<br>3.写出P（【a，【a】】）和P（【【1，【2，3】】】）的所有集合<br>4.若A⊆B，判断A的幂集是否⊆B的幂集。（∀x∈A，x∈B）<br>5.任意集合AB，A的幂集交B的幂集是否等于A交B的幂集（即证明P（A∩B）=P（A）∩P（B））<br>6.A的幂集-B的幂集是否等于A-B的幂集（任意举例）<br>7.证明对于任意集合ABC，有（A-B）<span class="hljs-attribute">-C</span>=A-（B∪C）    （用好那个特别重要的式子）<br>8.已知A⊆B，证明：（B-A）∪<span class="hljs-attribute">A</span>=B    （用好那个特别重要的式子）<br></code></pre></td></tr></table></figure><h3 id="第二节-包含排斥原理-序偶与笛卡儿乘积"><a href="#第二节-包含排斥原理-序偶与笛卡儿乘积" class="headerlink" title="第二节  包含排斥原理 序偶与笛卡儿乘积"></a>第二节  包含排斥原理 序偶与笛卡儿乘积</h3><h4 id="包含排斥原理"><a href="#包含排斥原理" class="headerlink" title="包含排斥原理"></a>包含排斥原理</h4><p><img src="/pic/67.png" alt="包含排斥原理一图通"></p><h5 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.某学校举行运动会，有短跑、跳高、跳远三项，二年级有<span class="hljs-number">180</span>人，已知有<span class="hljs-number">25</span>人三个项目都参加，参加两个项目以上的有<span class="hljs-number">85</span>人，全年级参加比赛总人次为<span class="hljs-number">250</span>人次。问有多少人没有参加任何项目?<br><span class="hljs-attribute">2</span>.<span class="hljs-number">12</span>名小朋友，<span class="hljs-number">8</span>人玩过山车，<span class="hljs-number">7</span>人玩旋转木马，<span class="hljs-number">5</span>人玩摩天轮，<span class="hljs-number">5</span>人玩过山车和旋转木马，<span class="hljs-number">4</span>人玩过山车和玩摩天轮，<span class="hljs-number">5</span>人旋转木马和玩摩天轮。问：有多少人三种都没玩？<br><span class="hljs-attribute">3</span>.<span class="hljs-number">90</span>名学生，<span class="hljs-number">55</span>人参加数学小组,<span class="hljs-number">44</span>人参加语文小组，<span class="hljs-number">33</span>人参加体育小组，<span class="hljs-number">36</span>人参加数学和语文小组，<span class="hljs-number">29</span>人参加数学和体育小组，<span class="hljs-number">25</span>人参加语文和体育小组。问:至少有多少人<span class="hljs-number">3</span>个小组都没参加?<br></code></pre></td></tr></table></figure><h5 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h5><p>1.<img src="/pic/68.png" alt="排斥原理练习一"><br>2.<img src="/pic/69.png" alt="排斥原理练习二"><br>3.23人</p><h4 id="序偶"><a href="#序偶" class="headerlink" title="序偶"></a>序偶</h4><p>有序的偶对。<br>若x≠y，则&lt;x,y&gt;≠&lt;y,x&gt;，但[x,y]&#x3D;[y,x]<br>序偶与集合的统一：&lt;x,y&gt; &#x3D; [[x],[x,y]]<br>序偶相等的定义：&lt;x,y&gt;&#x3D;&lt;u,v&gt; &lt;&#x3D;&gt;  x&#x3D;u 且 y&#x3D;v<br>序偶的推广： &lt; x , y , z &gt; &#x3D; &lt;&lt;x,y&gt;, z &gt;称为三元组.注意：&lt;&lt;x,y&gt;, z &gt;≠ &lt;x, &lt;y,z&gt;&gt;</p><h4 id="笛卡尔乘积"><a href="#笛卡尔乘积" class="headerlink" title="笛卡尔乘积"></a>笛卡尔乘积</h4><p>公式：A×B &#x3D; 【&lt;x,y&gt;|(x∈A)∧(y∈B)】（【】为大括号，因为直接打大括号系统会出错）<br>一些性质：<br><img src="/pic/92.png" alt="img"><br>下面这个定理不常用，了解即可<br><img src="/pic/93.png" alt="img"></p><h5 id="练习：-1"><a href="#练习：-1" class="headerlink" title="练习："></a>练习：</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">1</span>.若<span class="hljs-keyword">A</span>×B=空集，则<span class="hljs-keyword">A</span>=空集或B=空集；<br><span class="hljs-number">2</span>.<span class="hljs-keyword">A</span>×<span class="hljs-keyword">A</span>=B×B则<span class="hljs-keyword">A</span>=B；（需要讨论<span class="hljs-keyword">A</span>是否为空集）<br><span class="hljs-number">3</span>.ABCD为集合，则（<span class="hljs-keyword">A</span>∩B）×（C∩D）=（<span class="hljs-keyword">A</span>∩C）×（B∩D）<br><br>##### 答案：<br></code></pre></td></tr></table></figure><p>1.若AB都不是空集，则存在x∈A，y∈B使A×B（x，y），与题目矛盾<br>2.①若A为非空集；任意x∈A，&lt;x,x&gt;∈A×A，&lt;x,x&gt;∈B×B，所以x∈B，A为B的子集，同理B为A的子集。<br>②若A为空集：则B×B为空集，则B为空集A&#x3D;B</p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>定义：关系是两个集合的笛卡尔乘积的子集。<br>关系R是序偶的集合：若&lt;x,y&gt;∈R则记为xRy，反之记为xRy（在R上加一杠或者划掉R）<br>集合A到集合B的关系：A×B的子集。集合A上的关系：A×A的子集；</p><h4 id="关系的域"><a href="#关系的域" class="headerlink" title="关系的域"></a>关系的域</h4><p>关系R的前域: domR&#x3D;[x|(存在y)(&lt;x,y&gt;∈R)]（大括号）—&gt;所有的第一分量的集合<br>关系R的值域:ranR&#x3D;[y|(存在x)(&lt;x,y&gt;∈R)]（大括号）—&gt;所有的第二份量的集合<br>若R为AxB的子集，则domR⊆A 且ranR⊆B —&gt;前域和值域求并集<br>关系的域 FLD R&#x3D; domR U ranR<br>因为R ⊆ AxB ⊆ (AUB) x (AUB)，所以A到B的关系是(AUB)上的关系</p><h5 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h5><p>1.设X&#x3D;[1,2,3,4],求X上的关系&gt;及dom&gt;,ran&gt;.<br>2.x&#x3D;[1,2,3,~~~~~,m]求大于关系和大于等于关系的元素<br>3.若|A|&#x3D;m,|B|&#x3D;n,|A×B|&#x3D;?,A到B有多少个不同的关系(即A×B有多少个子集)，A上有多少不同的关系（即A×B有多少个子集）</p><h5 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h5><p>1.&gt;&#x3D;[&lt;2,1&gt;,&lt;3,1&gt;&lt;4,1&gt;&lt;3,2&gt;,&lt;4,2&gt;,&lt;4,3&gt;],剩下两个略<br>2.Cm2；Cm2+m<br>3.m*n；2^mn;2^m^2</p><h4 id="特殊的关系"><a href="#特殊的关系" class="headerlink" title="特殊的关系"></a>特殊的关系</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">IA=[&lt;x,x&gt;|x∈<span class="hljs-keyword">A</span>]是<span class="hljs-keyword">A</span>上的关系<br>全域关系：R=<span class="hljs-keyword">A</span>×B <br>空关系：R=空集<br>定义：<span class="hljs-keyword">A</span>到B的两个关系的交兵差不仍然是<span class="hljs-keyword">A</span>到B的关系<br></code></pre></td></tr></table></figure><h4 id="关系的表示"><a href="#关系的表示" class="headerlink" title="关系的表示"></a>关系的表示</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>.集合法（枚举表示法）：列举集合的所有元素（序偶）<br><span class="hljs-number">2</span>.集合法（叙述法）：叙述关系定义的判别条件<br><span class="hljs-number">3</span>.矩阵法：<span class="hljs-selector-tag">A</span>到<span class="hljs-selector-tag">B</span>的关系用<span class="hljs-selector-tag">A</span>行<span class="hljs-selector-tag">B</span>列的<span class="hljs-number">0</span>、<span class="hljs-number">1</span>矩阵表示<br><span class="hljs-number">4</span>.图：<span class="hljs-selector-tag">A</span>到<span class="hljs-selector-tag">B</span>的关系：用有向偶图表示（点表示集合元素，弧表示序偶）<br>      <span class="hljs-selector-tag">A</span>上的关系:用有向偶图表示（点表示集合元素，弧表示序偶）<br></code></pre></td></tr></table></figure><h4 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h4><p>1.R[&lt;1,1&gt;,&lt;2,2&gt;]的补集<br>2.（嵌套序偶）令S&#x3D;[1,2,3,4],A&#x3D;SxS,在A上有关系R:&lt;a,b&gt;R&lt;c,d&gt;，当且仅当a+d&#x3D;b+c,R?</p><h4 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h4><p>1.R的补集为[&lt;1,2&gt;,&lt;2,1&gt;]<br>2.<img src="/pic/94.jpg" alt="img"></p><h4 id="关系的性质（A上的关系）"><a href="#关系的性质（A上的关系）" class="headerlink" title="关系的性质（A上的关系）"></a>关系的性质（A上的关系）</h4><p>讨论非空集合A上的关系R（即R⊆A×A）</p><h5 id="自反性和反自反性（互斥）"><a href="#自反性和反自反性（互斥）" class="headerlink" title="自反性和反自反性（互斥）"></a>自反性和反自反性（互斥）</h5><p>自反性：(∀a∈A, &lt;a,a &gt;∈R；)<br>关系图中每个点都有环关系;矩阵是对角线元素全部为1;<br>反自反性：(∀a∈A, &lt;a,a&gt;∉R)<br>关系图中每个点都没环；关系矩阵是对角线元素全部为0;</p><h5 id="对称性和反对称性（有交集，也可以都没有）"><a href="#对称性和反对称性（有交集，也可以都没有）" class="headerlink" title="对称性和反对称性（有交集，也可以都没有）"></a>对称性和反对称性（有交集，也可以都没有）</h5><p>对称性： (∀a, b ∈A, 若&lt;a,b&gt;∈R，则&lt;b,a&gt;∈R)<br>关系图中任意两个不同的点之间要么没有边，要么有双向边；关系矩阵是对称矩阵<br>反对称性：(若a≠b，则&lt;a,b&gt;∉R或&lt;b,a&gt;∉R ；或者：∀a,b∈A, 若&lt;a,b&gt;∈R且&lt;b,a&gt;∈R, 则a&#x3D;b；)</p><h5 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h5><p>∀ a,b,c∈A, 若 &lt;a,b&gt;∈R 且 &lt;b,c&gt;∈R，则&lt;a,c&gt;∈R<br>关系图中任意两个点之间若经过第三点有路接通，则必有直达边;关系矩阵较复杂</p><h5 id="☆例子："><a href="#☆例子：" class="headerlink" title="☆例子："></a>☆例子：</h5><p>注意第一个图和第二个图的第二个式子的对比，说明了若有&lt;1,2&gt;和&lt;2,1&gt;互指，则传递出&lt;1,1&gt;,即必须要有环<br><img src="/pic/97.png" alt="img"><br><img src="/pic/98.png" alt="img"><br><img src="/pic/99.png" alt="img"><br><img src="/pic/100.png" alt="img"><br>练习：考试时一般会给出A和关系R，让你判断性质。<br>A&#x3D;[1,2,3,4];R&#x3D;[&lt;1,1&gt;&lt;1,2&gt;&lt;2,1&gt;&lt;2,3&gt;&lt;4,4&gt;]</p><h3 id="复合关系、逆关系"><a href="#复合关系、逆关系" class="headerlink" title="复合关系、逆关系"></a>复合关系、逆关系</h3><h4 id="复合关系"><a href="#复合关系" class="headerlink" title="复合关系"></a>复合关系</h4><p>定义复合关系：<br>设R是A到B的关系，S是B到C的关系，则RS称为R和S的复合关系，表示为<br>R°S &#x3D; [&lt;x,z&gt; | x∈A∧z∈C∧(存在y)(y∈B∧&lt;x,y&gt;∈R∧&lt;y,z&gt;∈S)]</p><h5 id="复合关系的性质"><a href="#复合关系的性质" class="headerlink" title="复合关系的性质"></a>复合关系的性质</h5><p>复合关系的关系矩阵：<br>由两个关系矩阵的逻辑乘（用0、1表示零和非零值）得到。<br>复合关系的关系图：<br>两点间有一点，接通这两点，省去中间点集，得到复合关系的关系图。<br>复合关系是不可交换的（没有公共域）<br>复合关系是可结合的。</p><h4 id="逆关系"><a href="#逆关系" class="headerlink" title="逆关系"></a>逆关系</h4><p>定义逆关系：<br>设R是A到B的关系， 将R中每一序偶元素顺序互换，得到的集合称为关系R的逆关系，表示为  Rc &#x3D; { &lt;y,x&gt;|&lt;x,y&gt;∈R}可见， Rc是B到A的关系。逆关系保持了关系的性质<br>有关定理：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs armasm">证明两个关系相等，实质上是证明两个集合（元素是序偶）相等<br>        (<span class="hljs-built_in">R1</span>∪<span class="hljs-built_in">R2</span>)c = R1c∪R2c <br>        (<span class="hljs-built_in">R1</span>∩<span class="hljs-built_in">R2</span>)c = R1c∩R2c<br>        (<span class="hljs-built_in">R1</span>-<span class="hljs-built_in">R2</span>)c = R1c-R2c<br>        (AB)c = BA<br>        ( <span class="hljs-built_in">R1</span><span class="hljs-built_in">R2</span>)c = R2c R1c<br>        (<span class="hljs-built_in">R1</span><span class="hljs-built_in">R2</span>) <span class="hljs-built_in">R3</span> = <span class="hljs-built_in">R1</span> (<span class="hljs-built_in">R2</span> <span class="hljs-built_in">R3</span>)  <br>R是非空集合X上的关系，有：<br>        R是对称的 &lt;=&gt; R= Rc<br>        R是反对称的 &lt;=&gt; R∩Rc 是Ix 的子集<br></code></pre></td></tr></table></figure><h3 id="闭包、集合的划分、集合的覆盖"><a href="#闭包、集合的划分、集合的覆盖" class="headerlink" title="闭包、集合的划分、集合的覆盖"></a>闭包、集合的划分、集合的覆盖</h3><p>关系R的自反（对称、传递）闭包：<br>是指包含R的、而且是自反的、最小的自反（对称、传递）关系，如果R本身是自反的（对称的、传递的），则其自反的（对称的、传递的）闭包就是R ，在原本的基础上令关系自反(对称、传递)<br><img src="/pic/102.png" alt="img"><br><img src="/pic/103.png" alt="img"><br>最大最小划分：<br>最小划分（划分的个数最少）：<br>该集合的全部元素组成一个分块。<br>最大划分（划分的个数最多）：<br>每个元素构成一个分块。<br>交叉划分、加细划分不要求</p><h3 id="等价关系、等价类、偏序关系"><a href="#等价关系、等价类、偏序关系" class="headerlink" title="等价关系、等价类、偏序关系"></a>等价关系、等价类、偏序关系</h3><h4 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h4><p>同时包含自反性，对称性，传递性的就是等价关系</p><h4 id="等价类-p131"><a href="#等价类-p131" class="headerlink" title="等价类(p131)"></a>等价类(p131)</h4><p>R是A上的等价关系，则<br>等价类 [a]R&#x3D; 【x|x∈A且aRx】<br>等价关系与划分互相决定，a上的等价类问由多少种等价关系，即问有多少种划分<br>练习：<br>证明&lt;a,b&gt;∈R&lt;&#x3D;&gt;[a]_r&#x3D;[b]_r;(主要利用对称性和传递性)</p>]]></content>
    
    
    <categories>
      
      <category>大学学习(大一下)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/03/19/hello-world/"/>
    <url>/2024/03/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大学物理（上）</title>
    <link href="/2024/03/19/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86-%E4%B8%8A/"/>
    <url>/2024/03/19/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86-%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="大学物理（上）"><a href="#大学物理（上）" class="headerlink" title="大学物理（上）"></a>大学物理（上）</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>大学物理的研究内容：<br>力学、电磁学、热学、震动和波动、量子物理<br>     本学期学习的内容：<br>     第一章：质点运动学<br>     第二章：质点动力学<br>     第三章：刚体力学<br>     第四章：连续体力学（自学）<br>     第五章：机械振动<br>     第六章：机械波<br>     第七章：光的干涉<br>     第八章：光的衍射<br>     第九章：光的偏振<br>     第十章：几何光学（自学）</p><h2 id="质点系"><a href="#质点系" class="headerlink" title="质点系"></a>质点系</h2><h3 id="第一节-参考系、坐标系、质点"><a href="#第一节-参考系、坐标系、质点" class="headerlink" title="第一节  参考系、坐标系、质点"></a>第一节  参考系、坐标系、质点</h3><p>坐标系：直角坐标系、极坐标系、自然坐标系等</p><h3 id="第二节-指点位置的描述"><a href="#第二节-指点位置的描述" class="headerlink" title="第二节  指点位置的描述"></a>第二节  指点位置的描述</h3><pre><code class="hljs"> 位置矢量：r=xi+yj+zk 大小为|r| 方向余弦值：坐标/模长； 平均速度v=Δr/Δt（这个v带→和—）；瞬时速度v=lim（t→0）Δr/Δt=dr/dt（这个v只带→）； 平均速率v=Δs/Δt（这个v带—）；瞬时速度v=lim（t→0）Δs/Δt=ds/dt（这个v什么也不带）；</code></pre><p><img src="/pic/13.jpg" alt="img"></p><h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><p><img src="/pic/14.jpg" alt="img"><br>答案：ABCD  ——–&gt;我靠，谁家好人出题出全选的啊</p><h3 id="第三节-切向加速度和法向加速度"><a href="#第三节-切向加速度和法向加速度" class="headerlink" title="第三节  切向加速度和法向加速度"></a>第三节  切向加速度和法向加速度</h3><p>一般研究这个东西的时候建立的是自由坐标系</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">切向加速度：改变了速度的大小<br>法向加速度：改变了速度的方向<br></code></pre></td></tr></table></figure><p><img src="/pic/15.jpg" alt="img"><br><img src="/pic/16.jpg" alt="img"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">曲率k<span class="hljs-operator">=</span>lim（Δs→<span class="hljs-number">0</span>）Δθ/Δs<span class="hljs-operator">=</span>dθ/ds  （曲率越大曲线弯曲得越厉害）<br>曲率半径<span class="hljs-operator">=</span><span class="hljs-number">1</span>/k<span class="hljs-operator">=</span>ds/dθ<br></code></pre></td></tr></table></figure><h3 id="第四节-几种常见的质点运动"><a href="#第四节-几种常见的质点运动" class="headerlink" title="第四节  几种常见的质点运动"></a>第四节  几种常见的质点运动</h3><h4 id="平抛运动"><a href="#平抛运动" class="headerlink" title="平抛运动"></a>平抛运动</h4><p>例题：<br>抛体运动是典型的平面匀加速运动，已知ā&#x3D;g，初速度与水平面的夹角为0，初速度大小为v，求解运动质点的运动方程、轨道方程、速度随时间的变化关系和位矢随时间的变化关系。</p><h4 id="圆周运动"><a href="#圆周运动" class="headerlink" title="圆周运动"></a>圆周运动</h4><p>一般建立极坐标系<br><img src="/pic/19.jpg" alt="img"><br><img src="/pic/20.jpg" alt="img"></p><h3 id="第五节-相对运动"><a href="#第五节-相对运动" class="headerlink" title="第五节  相对运动"></a>第五节  相对运动</h3><p>分解成沿x、y、z方向的向量并且进行运算，同向减，异向加</p><h3 id="第一章公式总结"><a href="#第一章公式总结" class="headerlink" title="第一章公式总结"></a>第一章公式总结</h3><p><img src="/pic/39.jpg" alt="img"></p><h2 id="质点动力学"><a href="#质点动力学" class="headerlink" title="质点动力学"></a>质点动力学</h2><h3 id="第一节-牛顿运动定律"><a href="#第一节-牛顿运动定律" class="headerlink" title="第一节  牛顿运动定律"></a>第一节  牛顿运动定律</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">牛顿第一定律（惯性定律）：力是改变物体运动状态的原因，不是物体运动状态不变的原因   <span class="hljs-comment">-----&gt;只有在惯性系中才成立</span><br>惯性系和非惯性系：在参考系中，不受外力的物体能否静止或匀速运动，若可以则为惯性系；否则为非惯性系；<br>牛顿第二定律：<br></code></pre></td></tr></table></figure><p><img src="/pic/21.jpg" alt="img"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">牛顿第三定律：作用力和反作用力大小相等方向相反，沿同一直线，分别作用在两个不同的物体上。（一定要区分平衡力！！！！）<br></code></pre></td></tr></table></figure><p>几种常见的力：<br>万有引力和重力（略）<br>弹力：（形变力）<br>1.正压力或支持力<br>2.拉力和张力（前者是外力，后者是内力）<br>3.弹簧的弹力<br>例题：关于张力的计算（注意，题目若未提及忽略绳子质量，则需要进行计算）<br>质量均匀分布的粗绳拉重物，已知:F&#x3D;150N， a&#x3D;0.2m&#x2F;s2，l&#x3D;4m，粗绳的质量为m&#x3D;2kg.求:距顶端为 x米处绳中的张力。<br>例题：牛顿第二定律的应用（注意一下：第一题乘ds那一步比较重要）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1.一个质量为m的的小珠子被细线的一段系住，细线的另一端 被钉子固定在墙上，细线长度为l。先拉住珠子使细线保持水平静止，然后松手让珠子下落。求细线下摆至于水平方向夹角为0时的速率和线中的张力。<br>2.一个质量为m的的炮弹，以初速度v。沿与水平面成α角的方向抛出，假设它受到的空气阻力为<span class="hljs-attribute">F</span>=-kmv，求此炮弹的弹道轨迹。<br></code></pre></td></tr></table></figure><h3 id="第二节-动量与动量守恒定律"><a href="#第二节-动量与动量守恒定律" class="headerlink" title="第二节  动量与动量守恒定律"></a>第二节  动量与动量守恒定律</h3><h4 id="冲量"><a href="#冲量" class="headerlink" title="冲量"></a>冲量</h4><p>n个指点组成的力学系统所受合外力的冲量等于系统总动量的增量。<br>内力不能改变系统的总动量（因为总是成对出现，会抵消掉）；但是内力能改变每一个质点的动量。<br>动量定理：<br><img src="/pic/27.jpg" alt="img"><br>质点系的动量定理：<br><img src="/pic/28.jpg" alt="img"></p><h4 id="动量守恒定律"><a href="#动量守恒定律" class="headerlink" title="动量守恒定律"></a>动量守恒定律</h4><p>合外力为0<br>有三点要注意：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1.动量守恒是矢量守恒<br>2.碰撞打击过程中所受的时候，内力远大于外力，动量守恒<br>3.分量方向动量守恒<br></code></pre></td></tr></table></figure><p>练习：<br>      <img src="/pic/29.jpg" alt="img"><br>      一个质量m&#x3D;140g的垒球以v&#x3D;40m·s’的速率沿水平方向飞向击球手，被球棒击中后它以相同的速率沿着与水平方向成0&#x3D;60°的仰角飞出。求垒球的平均打击力。设棒和球的接触时间为1.2ms。</p><h4 id="变质物体的运动方程"><a href="#变质物体的运动方程" class="headerlink" title="变质物体的运动方程"></a>变质物体的运动方程</h4><p><img src="/pic/31.jpg" alt="img"></p><h4 id="质心运动定律"><a href="#质心运动定律" class="headerlink" title="质心运动定律"></a>质心运动定律</h4><p>质心：质点系的运动中心，质心运动反映了质点系的整体运动趋势。<br><img src="/pic/32.jpg" alt="img"><br><img src="/pic/33.jpg" alt="img"><br><img src="/pic/34.jpg" alt="img"><br><img src="/pic/35.jpg" alt="img"></p><h3 id="第三节-功和能"><a href="#第三节-功和能" class="headerlink" title="第三节  功和能"></a>第三节  功和能</h3><h4 id="功"><a href="#功" class="headerlink" title="功"></a>功</h4><p>力在位移方向的积累</p><h5 id="保守力和非保守力：力做的功是否与过程和路径有关"><a href="#保守力和非保守力：力做的功是否与过程和路径有关" class="headerlink" title="保守力和非保守力：力做的功是否与过程和路径有关"></a>保守力和非保守力：力做的功是否与过程和路径有关</h5><p>观察一下计算的方法<br><img src="/pic/36.jpg" alt="img"><br><img src="/pic/38.jpg" alt="img"></p><h4 id="功率"><a href="#功率" class="headerlink" title="功率"></a>功率</h4><p><img src="/pic/37.jpg" alt="img"></p><h4 id="动能定理"><a href="#动能定理" class="headerlink" title="动能定理"></a>动能定理</h4><h5 id="质点的动能定理"><a href="#质点的动能定理" class="headerlink" title="质点的动能定理"></a>质点的动能定理</h5><p><img src="/pic/41.jpg" alt="img"></p><h5 id="质点系的动能定理"><a href="#质点系的动能定理" class="headerlink" title="质点系的动能定理"></a>质点系的动能定理</h5><p><img src="/pic/42.jpg" alt="img"></p><h5 id="势能"><a href="#势能" class="headerlink" title="势能"></a>势能</h5><p><img src="/pic/43.jpg" alt="img"><br><img src="/pic/44.jpg" alt="img"></p><h4 id="功能原理和机械能守恒定律"><a href="#功能原理和机械能守恒定律" class="headerlink" title="功能原理和机械能守恒定律"></a>功能原理和机械能守恒定律</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">功能原理：一切外力与所有非保守内力做功的代数和等于机械能增量<br>机械能守恒定律：只有保守内力做功或非保守内力与外力的总功为0<br></code></pre></td></tr></table></figure><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">一根质量为m长为L的匀质链条,放在摩擦系数为μ的水平桌面上,其一端下垂,长度为<span class="hljs-selector-tag">a</span>,如图所示,设链条由静止开始运动，求:(<span class="hljs-number">1</span>)链条离开桌面过程中摩擦力所做的功;(<span class="hljs-number">2</span>)链条刚刚离开桌<br>面时的速率。<br></code></pre></td></tr></table></figure><h3 id="第四节-角动量-角动量守恒定律"><a href="#第四节-角动量-角动量守恒定律" class="headerlink" title="第四节  角动量 角动量守恒定律"></a>第四节  角动量 角动量守恒定律</h3><pre><code class="hljs"> 角动量（又叫动量矩）L=r×P=|r|*|P|*sinα=Iw=mvr； （方向用右手螺旋定则判断） 力矩：M=r×F=|r|*|F|*sinα</code></pre><h4 id="角动量定理"><a href="#角动量定理" class="headerlink" title="角动量定理"></a>角动量定理</h4><p>M&#x3D;dL&#x2F;dt；力矩在某方向上的分量Mz&#x3D;dLz&#x2F;dt；</p><h4 id="角动量守恒定律"><a href="#角动量守恒定律" class="headerlink" title="角动量守恒定律"></a>角动量守恒定律</h4><p>M&#x3D;0时，L&#x3D;常矢量；<br>例题：<br><img src="/pic/46.jpg" alt="img"></p><h3 id="第二章公式小结"><a href="#第二章公式小结" class="headerlink" title="第二章公式小结"></a>第二章公式小结</h3><p><img src="/pic/40.jpg" alt="img"></p><h2 id="刚体力学"><a href="#刚体力学" class="headerlink" title="刚体力学"></a>刚体力学</h2><h3 id="刚体运动学"><a href="#刚体运动学" class="headerlink" title="刚体运动学"></a>刚体运动学</h3><p>刚体：任意两质点之间的距离在外里作用下始终保持不变的物体</p><h3 id="平动：沿着一条直线运动，可以看成是质点"><a href="#平动：沿着一条直线运动，可以看成是质点" class="headerlink" title="平动：沿着一条直线运动，可以看成是质点"></a>平动：沿着一条直线运动，可以看成是质点</h3><h3 id="转动"><a href="#转动" class="headerlink" title="转动"></a>转动</h3><p>转动的角速度、定轴转动等，看第一章就行<br>例题：<br><img src="/pic/47.jpg" alt="img"><br><img src="/pic/48.jpg" alt="img"><br><img src="/pic/49.jpg" alt="img"></p><h3 id="刚体动力学"><a href="#刚体动力学" class="headerlink" title="刚体动力学"></a>刚体动力学</h3><p>M&#x3D;r×F（这里的F指的是外力在转动平面的分力）<br>注意：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1.通过转轴或者与转轴平行的力对转轴不产生力矩<br>2.刚体内各质点的内力对转轴不产生力矩<br>3.对于刚体的定轴转动，不同的力作用于刚体不同位置上，可以产生相同的效果。<br></code></pre></td></tr></table></figure><p>例题：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.一个长L,质量m的均匀细直棒,其一端有一固定的光滑水平轴因而可长以在竖直平面内转动。最初棒静止在水平位置,求它由此下摆<span class="hljs-number">0</span>角时，细棒所受的重力对转轴的力矩。<br><span class="hljs-attribute">2</span>.一半径为R，质量为m匀质圆盘，平放在粗糙的水平桌面上。设盘与桌面间摩擦系数为μ，令圆盘绕通过中心且垂直盘面的轴旋转，问圆盘受到的阻力矩是多少?<br></code></pre></td></tr></table></figure><h4 id="刚体的转动惯量："><a href="#刚体的转动惯量：" class="headerlink" title="刚体的转动惯量："></a>刚体的转动惯量：</h4><p><img src="/pic/52.jpg" alt="img"><br><img src="/pic/53.jpg" alt="img"><br>平行轴定理和垂直轴定理（注意一下平行轴定理是比较重要的内容）<br><img src="/pic/54.jpg" alt="img">   <img src="/pic/55.jpg" alt="img"><br>三个例题，区分一下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">例1:一细圆环半径为r，质量为m，求圆环对通过圆心且垂直环面的轴的转动惯量。</span><br>注意一下第二个例子的表示使用面密度乘以面积。<br><span class="hljs-section">例2:求质量为m，半径为R的圆盘绕通过中心并与圆面垂直的转轴的转动惯量，设质量在盘上均匀分布。</span><br>注意一下第三个例子的表示使用线密度乘以长度。<br><span class="hljs-section">例3:求质量为m，长为1的匀质细棒对下列给定转轴的转动惯量:</span><br>(1)转轴通过棒的中心并与棒垂直;(2)转轴通过棒的一端并与棒垂直。<br>注意一下第四个例子需要用到角速度的定义进行换算       <br><span class="hljs-section">例4:一根长L,质量m的均匀细直棒,其一端有一固定的光滑水平轴因而可以在竖直平面内转动.最初棒静止在水平位置,求它由此下摆0角时的角加速度和角速度。</span><br></code></pre></td></tr></table></figure><h3 id="冲量矩和角动量守恒定律"><a href="#冲量矩和角动量守恒定律" class="headerlink" title="冲量矩和角动量守恒定律"></a>冲量矩和角动量守恒定律</h3><p>角动量守恒：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1.刚体定轴转动<br>2.多个物体组成时，角动量的矢量和不变<br>3.<span class="hljs-attribute">Iawa</span>=（Ia+Ib）w<br></code></pre></td></tr></table></figure><h3 id="力矩的功"><a href="#力矩的功" class="headerlink" title="力矩的功"></a>力矩的功</h3><p>表达方式：力矩M在θ上的积累<br>动能：1&#x2F;2<em>Iw^2-1&#x2F;2</em>Iw^2（相关量的记忆方法：把I当成m，M当成F）</p><h3 id="第三章必须要记得的结论"><a href="#第三章必须要记得的结论" class="headerlink" title="第三章必须要记得的结论"></a>第三章必须要记得的结论</h3><p><img src="/pic/88.jpg" alt="img"><br><img src="/pic/89.jpg" alt="img"></p><h2 id="振动力学"><a href="#振动力学" class="headerlink" title="振动力学"></a>振动力学</h2><h3 id="简谐振动的描述"><a href="#简谐振动的描述" class="headerlink" title="简谐振动的描述"></a>简谐振动的描述</h3><p>振动时一种特殊的运动形式。有特定值和周期性。（在某一特定值附近来回变化，具有周期性）<br>简谐振动：运动时物体的位移（或角位移）和时间的函数图象为正余弦函数。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs excel">位移表达式：y(<span class="hljs-built_in">t</span>)=<span class="hljs-built_in">Acos</span>(wt+φ_0)<br>速度表达式：v=dy(<span class="hljs-built_in">t</span>)/dt=-wAsin(wt+φ_0)=wAcos(wt+φ_0+<span class="hljs-built_in">PI</span>/<span class="hljs-number">2</span>)<br>加速度表达式：a=dy/dt=-w^<span class="hljs-number">2</span><span class="hljs-built_in">Acos</span>(wt+φ_0)=w^<span class="hljs-number">2</span><span class="hljs-built_in">Acos</span>(wt+φ_0+<span class="hljs-built_in">PI</span>)<br>各个特征量的表达：<br>振幅：A<br>角频率：w=<span class="hljs-number">2</span>PIv   rad/s<br>频率：v（和上面那个v不一样 ） Hz <span class="hljs-built_in">or</span> <span class="hljs-number">1</span>/s<br>周期：<span class="hljs-built_in">T</span> =(<span class="hljs-number">2</span><span class="hljs-built_in">PI</span>)/w  <span class="hljs-built_in">or</span>  <span class="hljs-number">1</span>/v   s<br>相位：φ（<span class="hljs-built_in">t</span>）=wt+φ_0    rad    <br>初相<span class="hljs-symbol">:</span> -<span class="hljs-built_in">PI</span>&lt;= φ_0 &lt;=<span class="hljs-built_in">PI</span>，初相&gt;<span class="hljs-number">0</span>时图像向左平移，反之向右；<br>对于角频率相同的振动，相位差=初相位之差。相位差为<span class="hljs-built_in">PI</span>的奇数倍，则称两个矢量反向；相位差为<span class="hljs-built_in">PI</span>的偶数倍，则称两个矢量同向。 相位差&gt;<span class="hljs-number">0</span>为超前，否则为落后<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">简谐振动的描述方法：<br><span class="hljs-number">1.</span>解析法：利用上面<span class="hljs-number">3</span>个表达式描述<br><span class="hljs-number">2.</span>曲线图法：画图呗。<br><span class="hljs-number">3.</span>☆☆☆旋转矢量图法：<span class="hljs-comment">(求简谐振动表达式的时候很方便)</span><br>①画一条竖直y轴，向上为正方向，一个单位长度的向量从与y轴正方向夹角为φ_<span class="hljs-number">0</span>的方向出发逆时针旋转。此时y=Acos<span class="hljs-comment">(wt+φ)</span>。A表示的是矢量的长度，w表示的是旋转角速度，φ_<span class="hljs-number">0</span>表示与y轴的夹角。<br>②画x轴也一样，一般常见的是用x表示。建系画参考圆进行计算。<br></code></pre></td></tr></table></figure><p>当给出沿x轴正方向运动时—&gt;表示v&gt;0</p><h3 id="简谐运动的动力学方程"><a href="#简谐运动的动力学方程" class="headerlink" title="简谐运动的动力学方程"></a>简谐运动的动力学方程</h3><h4 id="平衡位置"><a href="#平衡位置" class="headerlink" title="平衡位置"></a>平衡位置</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">机械平衡：<br>1.平动平衡；Σ<span class="hljs-attribute">F</span>=0<br>2.转动平衡：Σ<span class="hljs-attribute">M</span>=0<br></code></pre></td></tr></table></figure><h4 id="回复力"><a href="#回复力" class="headerlink" title="回复力"></a>回复力</h4><p>回复力（力矩）：<br>使物体回到平衡位置的力（力矩）。常见的力为：弹力、分子间作用力、重力等；<br>合外力和位移始终反向，且合外力的方向始终指向平衡位置。</p><h5 id="线性回复力（F与位移成正比，与位移方向相反）"><a href="#线性回复力（F与位移成正比，与位移方向相反）" class="headerlink" title="线性回复力（F与位移成正比，与位移方向相反）"></a>线性回复力（F与位移成正比，与位移方向相反）</h5><p>F&#x3D;-kx–&gt;d^2x&#x2F;dt^2+w^2x&#x3D;0(w&#x3D;(k&#x2F;m)^1&#x2F;2)<br>弹簧谐振子w：固有（圆）频率（☆取决于系统内在性质）<br>位移通解x：Acos(wt+φ)</p><h6 id="水平弹簧振子"><a href="#水平弹簧振子" class="headerlink" title="水平弹簧振子"></a>水平弹簧振子</h6><p><img src="/pic/85.png" alt="img"></p><h6 id="竖直弹簧振子"><a href="#竖直弹簧振子" class="headerlink" title="竖直弹簧振子"></a>竖直弹簧振子</h6><p><img src="/pic/86.png" alt="img"></p><h6 id="单摆"><a href="#单摆" class="headerlink" title="单摆"></a>单摆</h6><p>T&#x3D;2PI（l&#x2F;g）^1&#x2F;2</p><h6 id="复摆"><a href="#复摆" class="headerlink" title="复摆"></a>复摆</h6><p>下面这个例题用了平行轴定理<br><img src="/pic/87.png" alt="img"></p><h3 id="简谐振动的能量"><a href="#简谐振动的能量" class="headerlink" title="简谐振动的能量"></a>简谐振动的能量</h3><h4 id="水平弹簧振子的能量"><a href="#水平弹簧振子的能量" class="headerlink" title="水平弹簧振子的能量"></a>水平弹簧振子的能量</h4><p>E_k&#x3D;1&#x2F;2mw^2A^2sin^2(wt+φ);<br>E_p&#x3D;1&#x2F;2kA^2cos^2(wt+φ);<br>k&#x3D;w^2m;<br>一个周期内动能和势能的平均值为1&#x2F;4 kA^2;</p><h3 id="简谐运动的合成"><a href="#简谐运动的合成" class="headerlink" title="简谐运动的合成"></a>简谐运动的合成</h3><p>解析法或图像法<br><img src="/pic/101.png" alt="img"><br>例题：<br>求N个同方向、同频率的简谐振动的和振动。</p>]]></content>
    
    
    <categories>
      
      <category>大学学习(大一下)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等数学（下）</title>
    <link href="/2024/03/19/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2024/03/19/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="高等数学下"><a href="#高等数学下" class="headerlink" title="高等数学下"></a>高等数学下</h1><h2 id="第八章-向量代数与空间解析几何"><a href="#第八章-向量代数与空间解析几何" class="headerlink" title="第八章  向量代数与空间解析几何"></a>第八章  向量代数与空间解析几何</h2><h3 id="第一节-向量及其线性运算"><a href="#第一节-向量及其线性运算" class="headerlink" title="第一节  向量及其线性运算"></a>第一节  向量及其线性运算</h3><p>沿（x&#x2F;y&#x2F;z）方向余弦值：坐标值&#x2F;模长<br>Prja（下标）b：b在a方向上的投影<br>（其余的东西都是高中学过的，不做赘述）</p><h3 id="第二节-向量积、数量积、混合积"><a href="#第二节-向量积、数量积、混合积" class="headerlink" title="第二节  向量积、数量积、混合积"></a>第二节  向量积、数量积、混合积</h3><pre><code class="hljs"> 向量积：a·b=|a||b| cosθ 数量积：a×b=|a||b| sinθ/行列式D的值（其中第一行为i，j，k，第二第三行为a、b的坐标） 混合积：（a×b）·c的值为行列式D的值（其中一到三行分别为a，b，c的坐标值）</code></pre><h3 id="第三节-平面及其方程"><a href="#第三节-平面及其方程" class="headerlink" title="第三节  平面及其方程"></a>第三节  平面及其方程</h3><pre><code class="hljs"> 平面方程求法：点法式 已知平面的法向量n=（A，B，C）-&gt;n=AB×AC；有一点为（x0，y0，z0）； 则平面方程为A(x-x0)+B(y-y0)+C(z-z0)=0;</code></pre><h3 id="第四节-空间直线及其方程"><a href="#第四节-空间直线及其方程" class="headerlink" title="第四节  空间直线及其方程"></a>第四节  空间直线及其方程</h3><pre><code class="hljs"> 空间直线求法：对称式（也叫点向式）及其参数方程 已知直线的一点（x0，y0，z0）；直线的方向向量s=（A，B，C）-&gt;n1×n2,即两平面交线的方向向量为二者法向量叉乘； 则(x-x0)/A=(y-y0)/B=(z-z0)/C; 待定系数法求平面束：(ax+by+cz)+λ(Ax+By+Cz)=0</code></pre><h3 id="第五节-曲面及其方程"><a href="#第五节-曲面及其方程" class="headerlink" title="第五节  曲面及其方程"></a>第五节  曲面及其方程</h3><pre><code class="hljs"> 椭球面：X^2/a^2+Y^2/b^2+Z^2/c^2=R^2 (当且仅当a=b=c时为球面) 锥面：Z^2=X^2/a^2+Y^2/b^2   (当且仅当a=b时为圆锥面) 抛物面：X^2+Y^2+Z=R^2 单叶双曲面：X^2/a^2+Y^2/b^2-Z^2/c^2=1  （双曲线绕谁转谁不变） 双叶双曲面：X^2/a^2-Y^2/b^2-Z^2/c^2=1  （双曲线绕谁转谁不变） 椭圆/双曲抛物面：X^2/a^2+Y^2/b^2=Z  /   X^2/a^2-Y^2/b^2=Z 柱面：一般没有那个字母母线就平行于哪个轴</code></pre><h3 id="第六节-空间曲线及其方程"><a href="#第六节-空间曲线及其方程" class="headerlink" title="第六节  空间曲线及其方程"></a>第六节  空间曲线及其方程</h3><pre><code class="hljs"> 投影求法：若都有z，则先消去z，再联立z=0，找到封顶和封底。 若没有z，则先把z=0代入有z的方程，观察是否切到另一平面的底面</code></pre><p>空间曲线的参数方程：<br>X&#x3D;a cos w t；Y&#x3D;a sin w t；Z&#x3D;v t  -&gt;螺旋上升成一个圆柱</p><h2 id="第九章-多元函数微分法及其应用"><a href="#第九章-多元函数微分法及其应用" class="headerlink" title="第九章  多元函数微分法及其应用"></a>第九章  多元函数微分法及其应用</h2><h3 id="第一节-多元函数的基本概念"><a href="#第一节-多元函数的基本概念" class="headerlink" title="第一节 多元函数的基本概念"></a>第一节 多元函数的基本概念</h3><h4 id="一些新定义的点"><a href="#一些新定义的点" class="headerlink" title="一些新定义的点"></a>一些新定义的点</h4><pre><code class="hljs"> 内点：在x-o-y平面中趋近于一点的邻域内的点叫内点 外点：在x-o-y平面中趋近于一点的邻域外的点叫外点 边界点：在x-o-y平面中趋近于一点的邻域上的点叫边界点 E指的是边界点的全体，内点一定属于E，外点一定不属于E，边界点都有可能。 聚点：任意一个点P，去心邻域中总有E中的点，则称P为E的聚点</code></pre><h4 id="平面点集"><a href="#平面点集" class="headerlink" title="平面点集"></a>平面点集</h4><pre><code class="hljs"> 开集：点集E的点都是E的内点 闭集：点集E的边界点都属于E 连通集：点集E中任意两点联通的折线属于E 区域：连通的开集 闭区域：联通的闭集 有界集/无界集：顾名思义</code></pre><h4 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h4><p>极限的定义：<br>和一元函数一样，二元函数的极限就是在x-o-y平面内从各个方向逼近于一个点的值<br>极限的求法：<br>和一元函数一样，需要用到有理化、代入、等价无穷小等方法。<br>连续的定义：l i m(x ,y)-&gt;(x0,y0)f(x, y)&#x3D;f(x0,y0)；<br>证明极限不存在：<br>因为是二维平面，所以要证明极限时要从多个方向逼近。证明只用它的值会变。</p><h5 id="练习例题"><a href="#练习例题" class="headerlink" title="练习例题"></a>练习例题</h5><pre><code class="hljs"> 1.L i m(x-&gt;+∞, y-&gt;+∞)(x^2+y^2)*e^-(x^2+y^2)  (洛必达法则) 2.L i m(x-&gt;0,y-&gt;0)x y/(x^2+y^2)^1/2    (夹逼定理) 3.Lim(x ,y)-&gt;(0,0)(x^2+y^2)^1/2+sin(x^2+y^2)^1/2/(x^2+y^2)^3/2 (泰勒展开或洛必达) （sin x =x-1/3! X^2+0(u^3)） 4.Lim(x ,y)-&gt;(0,0)sin(x^2y)/(x^2+y^2)      (基本不等式)</code></pre><h5 id="练习题：（证明在（0，0）极限不存在）"><a href="#练习题：（证明在（0，0）极限不存在）" class="headerlink" title="练习题：（证明在（0，0）极限不存在）"></a>练习题：（证明在（0，0）极限不存在）</h5><pre><code class="hljs"> 1.f（x）=x y/(x^2+y^2),x^2+y^2≠0；0,x^2+y^2=0;  (切记要利用偏导的定义，定一求一 ) 2.l i m(x ,y)-&gt;(0,0) x^2y/(x^4+y^2)  (选好一个方向趋近于（0，0）点) 3.  l i m(x ,y)-&gt;(0,0) (1+xy)^1/(x+y)</code></pre><h3 id="第二节-偏导数"><a href="#第二节-偏导数" class="headerlink" title="第二节   偏导数"></a>第二节   偏导数</h3><p>定义：沿着某个方向的斜率，定一求一，把另一个自变量当成常数进行求导<br>偏导≠&gt;连续<br>若函数连续，则∂^2 z&#x2F;∂x<em>∂y&#x3D;∂^2 z&#x2F;∂y</em>∂x </p><h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><pre><code class="hljs"> 1.f(x ,y)=x+(y-1) arc sin(x/y)^1/2,求f x(x,1) 2.设函数u=f(r)二阶可导，且满足方程∂^2u/∂x^2+∂^2u/∂y^2=4,其中r=（x^2+y^2）^1/2,求f(r)</code></pre><h3 id="第三节-全微分"><a href="#第三节-全微分" class="headerlink" title="第三节  全微分"></a>第三节  全微分</h3><pre><code class="hljs"> 偏增量：f(x+Δx ,y)-f(x ,y) / f(x ,y+Δy)-f(x ,y) 偏微分: f x(x ,y)Δx/ f y(x ,y)Δy，其中Δx=d x，Δy=d y 全增量：Δz=f(x+Δx ,y+Δy)-f(x ,y)=Ax +By+ρ(0); ρ(0)=(x^2+y^2)^1/2 全微分：d z=f x(x ,y)Δx/ f y(x ,y)Δy</code></pre><p>可微-&gt;连续&#x2F;偏导存在<br>这是因为,  如果z&#x3D;f(x, y)在点(x, y)可微, 则Δz&#x3D;f(x+Δx, y+Δy)-f(x, y) &#x3D;AΔx+BΔy+o(r),<br>于是lim（ρ→0）Δz&#x3D;0，则l i m(Δx , Δy)-&gt;(0,0) f(x+Δx,y+Δy)&#x3D;lim(ρ-&gt;0)[f(x,y)+Δz]&#x3D;f(x,y)<br>偏导存在且连续-&gt;可微  （二者缺一不可）<br><img src="/pic/10.png" alt="img"><br><img src="/pic/12.png" alt="img"><br><img src="/pic/11.png" alt="img"><br>求近似值的方法：<br>设定一个函数并且给x 、y赋值；再利用Δz≈d z&#x3D;f x(x ,y)Δx+ f y(x ,y)Δy求出Δz；最后利用原式&#x3D;z(x ,y)+Δz算出近似值</p><h3 id="第四节-多元复合函数的求导法则"><a href="#第四节-多元复合函数的求导法则" class="headerlink" title="第四节  多元复合函数的求导法则"></a>第四节  多元复合函数的求导法则</h3><h4 id="一元函数和多元函数符合求导"><a href="#一元函数和多元函数符合求导" class="headerlink" title="一元函数和多元函数符合求导"></a>一元函数和多元函数符合求导</h4><p>定义：若有z(u,v),u(t),v(t),求dz&#x2F;dt （一元函数再多都一样）<br>∂z先对它自己的一个变量求偏导，再对那一个变量进行求偏导。<br>则有链式法则:dz&#x2F;dt &#x3D; ∂z&#x2F;∂u * du&#x2F;dt + ∂z&#x2F;∂v * dv&#x2F;dt;   dz&#x2F;dt  称为全导数；<br>证明：先利用连续的定义把Δz展开成：Δz &#x3D; ∂z&#x2F;∂u * Δu + ∂z&#x2F;∂v * Δv。<br>      然后再两边同时除dt得到结论。</p><h4 id="多元函数和多元函数复合"><a href="#多元函数和多元函数复合" class="headerlink" title="多元函数和多元函数复合"></a>多元函数和多元函数复合</h4><p>定义：若有z&#x3D;f(x,y),u(x,y),v(x,y),求若有z(u,v),u(t),v(t),求∂z&#x2F;∂x和∂z&#x2F;∂y<br>∂z先对它自己的一个变量求偏导，再对那一个变量进行求偏导。<br>则有链式法则：∂z&#x2F;∂x &#x3D; ∂z&#x2F;∂u * ∂u&#x2F;∂x + ∂z&#x2F;∂v * ∂v&#x2F;∂x;<br>             ∂z&#x2F;∂y &#x3D; ∂z&#x2F;∂u * ∂u&#x2F;∂y + ∂z&#x2F;∂v * ∂v&#x2F;∂y;<br>例题：<br>1.u&#x3D;f(x.y.z)&#x3D;e^(x^2+y^2+z^2),z&#x3D;x^2siny,求∂z&#x2F;∂x;∂z&#x2F;∂y<br>2.(☆这里求二阶导很重要)设w&#x3D;f(x+y+z,xyz)，f具有二阶偏导数，求∂w&#x2F;∂x，∂^2w&#x2F;∂x∂y<br>3.u&#x3D;x-2y ,v&#x3D;x+ay ,且方程 6∂^2z&#x2F;∂x^2 - ∂^2z&#x2F;∂y^2 + ∂^2z&#x2F;∂x∂y&#x3D;0可以简化为∂^2z&#x2F;∂u∂v &#x3D;0,求常数a；<br>4.设z&#x3D;f(2x+3y,x^2y)+g(xy^2)，求∂^2z&#x2F;∂x∂y;<br>答案：<br>1.<img src="/pic/83.png" alt="img"><br>2.3.<img src="/pic/90.jpg" alt="img"><br>3.<img src="/pic/84.jpg" alt="img"><br>4.3.<img src="/pic/91.jpg" alt="img"></p><h3 id="第五节-隐函数的求导"><a href="#第五节-隐函数的求导" class="headerlink" title="第五节  隐函数的求导"></a>第五节  隐函数的求导</h3><h4 id="一个方程的情形"><a href="#一个方程的情形" class="headerlink" title="一个方程的情形"></a>一个方程的情形</h4><p>隐函数存在定理1：<br>设函数在点的某一邻域内具有连续的偏导数，且F(x_0,y_0)&#x3D;0,F_y(x_0,y_0)≠0,则方程F(x_0,y_0)&#x3D;0在点(x_0,y_0)的某一邻域内恒能唯一确定一个单值连续且具有连续导数的函数y&#x3D;f(x)，它满足条件y_0&#x3D;f(x_0)，并有dy&#x2F;dx&#x3D;-（F_x&#x2F;F_y）<br>隐函数存在定理2：<br>设函数在点的某一邻域内具有连续的偏导数，且F(x_0,y_0,z_0)&#x3D;0,F_z(x_0,y_0,z_0)≠0,则方程F(x_0,y_0,z_0)&#x3D;0在点(x_0,y_0,z_0)的某一邻域内恒能唯一确定一个单值连续且具有连续导数的函数z&#x3D;f(x,y)，它满足条件z_0&#x3D;f(x_0,y_0)，并有∂z&#x2F;∂x&#x3D;-(Fx&#x2F;Fz);∂z&#x2F;∂y&#x3D;-(Fy&#x2F;Fz).</p><h4 id="方程组的情形"><a href="#方程组的情形" class="headerlink" title="方程组的情形"></a>方程组的情形</h4><p>由方程组可以确定隐函数组（谁是谁的函数），利用克拉默法则-&gt;雅可比行列式，系数矩阵的行列式的值不能为0，因为会由无穷多解。<br>步骤：<br>若为对一个变量求导：(问什么导就求什么导)<br>先两边同时对分母那个自变量求导(复合函数求导)，然后利用克拉默法则求出答案<br>若为对两个变量求导：(问什么导就求什么导)<br>1.先两边同时对分母那个自变量求导(复合函数求导)，然后利用克拉默法则求出答案。-&gt;直接法<br>2.若u（x,y）,v(x,y),则求导数的话要用雅可比行列式，分母为F、G关于u、v的导数，分子就是求啥替换啥。-&gt;公式法</p><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><p>设F（u，v）有连续偏导数，证明由方程F（x+z&#x2F;y，y+z&#x2F;x）所确定的函数z&#x3D;（x，y）满足x ∂z&#x2F;∂x+y ∂z&#x2F;∂y&#x3D;z-xy</p><h3 id="第六节-☆多元函数微分学的几何应用（与梯度下降有关）"><a href="#第六节-☆多元函数微分学的几何应用（与梯度下降有关）" class="headerlink" title="第六节  ☆多元函数微分学的几何应用（与梯度下降有关）"></a>第六节  ☆多元函数微分学的几何应用（与梯度下降有关）</h3><h4 id="空间曲线的切线与法平面"><a href="#空间曲线的切线与法平面" class="headerlink" title="空间曲线的切线与法平面"></a>空间曲线的切线与法平面</h4><p>1.如果是参数方程，则x、y、z分别对参数求导求出切线的方向向量，然后可以通过点向式求切线，通过点法式求法平面<br>2.若不是参数方程，则将x&#x2F;y&#x2F;z作为参数进行计算</p><h4 id="空间曲线的切平面"><a href="#空间曲线的切平面" class="headerlink" title="空间曲线的切平面"></a>空间曲线的切平面</h4><p>面在点处的法向量为对x、y、z分别求偏导的结果<br>TO BE CONTINUE……∂</p>]]></content>
    
    
    <categories>
      
      <category>大学学习(大一下)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一封来自湛江的信</title>
    <link href="/2024/02/09/%E4%B8%80%E5%B0%81%E6%9D%A5%E8%87%AA%E6%B9%9B%E6%B1%9F%E7%9A%84%E4%BF%A1/"/>
    <url>/2024/02/09/%E4%B8%80%E5%B0%81%E6%9D%A5%E8%87%AA%E6%B9%9B%E6%B1%9F%E7%9A%84%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="a47dd5f75f3a0cafa8cd87404323766a258a694e811212a7e0e6a28fcccdb006">63d56a750651cce9ce2fc6641c322ec6c5fd1f6ad938da4a06404e20ab81d3d9e2b815c2240d1182a6accfa29e4aa342af86e7927835c83cf25739c5af0e378ff3fb97dc197681244f7fec055d54d8afe436848e03d36963580f115112b214114891b46db93feeed5f3b0b828d7d882bc8e72556e2c57f078924bbfe5b2953b52bfb173af79d7ac449cb4dd1d9dd5b7db2f86d26fcfa18b35678202493f66e4a264102c2558352061c23c06400b4625d67cc8092db04a35aae0446f9786754f70df455600ab5ba0a0d20ccd617095eb706ca42e4130159e7f6eeaf1c8df3411515357372f50058c55a5734d33278930dbcf77653c364af4fb8bd9d88e0fc19e27887c7d2f7adf77572c2966a7bc144cb0d3a556c2a5318e4ff68376c60d58ee1b83ea54c4b498b49db5fda4a0131d88d5548fe5dc6e2b762e202dc498f9cbb08b5a03d9c68c8921f2017b2c149d958dea50450c29f18f4d43c7f3adc47a920591016f5821f054c82132717caac6eea4e2a54532a8409cdbd0127b20f420a075f2dd6ef5cd7d67bf9834a6e4fc940e31f36fc316d95cc2d411ef352ba6a01a6175eec36b1d4a28eeb91ae37fc25ea1204d6832d9c4702cbca8c79ef9393b11999b05bdb5958d23f9383e9a97692aeb0f577a67b74791b3872c11a6cbd3a812a193f3ca6850fd97d6becc2719c0f59962bbc1dc60c2b798d5a3c8be62bc30bb30b08e1a1c6874a026776501baa857ee4541207546c6cd64ef95677d267961804f40b444caa7771680bfa49ef7d06a52be0280e7542387a5f177907717a61aafc18dcecbfaba22c191618d0df2e819d56cbdf1045912b833e1ae41acc2567351fdd89fdb294b73ce61f7324f254d5f51bbcd64ff745f7c7263109a64a7dcae9744c41b95981d0ace46cf44683d505102c350e7315c4974fa7e70dd2c2dfd682ee45fc185dc9c000002f3747a112ba1c831e4e1afd6f113d9c6a1118ed24306695fe4bacf92860f8546aa9243b0332139e2c4b99059e5ca749e00cf19d0ee6f15b5d2148c8f9cd16de36e612981073959e003fb29fe14605bbad8b0944fede9ce0b268be9667f127482748b0f0eda9c585dc3bbe8d0e3eceac8c26aa18345133235321ff45358beeb3a75b69e81c77dd8cc1ccb4041430506cad82d2c1b74d34f324729ef910141feb451217891a8ca391241e9a0f8929215a623d4287a260eb7e5b2ee26701d48c714addae6b182c4e98621ea9148a1d2c2b113ae578c65627034e83240e652b3f5e22828f70b4340e3415e272eb5ca5c0fc1832cbca6fa851041bedd1276db8df6aea41f04383f807c106978d4670ecea6b25198f7069f90f2fb8cdfcc7271cc782efa11e1f2faa59e27fe77baa2c5312f0a4c31a1b65ab145fbeaa1d2489e323790f0f77cf557d83db99b9f9800fb66eaaf2dbd6cee9fe1fbb447b69dd2770f38cebb6a1963833dde649c4b49640ddd3a835882b572de15c15b5453f96c663501be5b4afa7a92febda8c6dbde8c80904a4fa8db4c9085269cb2d78967cfb3e40ce557cc3242bf04d71437b0f965ddeccfd222b57188eaf235c9727533b33a4a02a70dd16bfabc34b7ec2a345d1c2e10134e5c7a68aa2ef7beab0ae14ba6a2467ff1cad865a0e259f5077b426e951e8b7bfb64dda63960b3162ea37884bf83a00d80ede599ed1eb81160819e5db55891adf86c8259aaf9ac74d9924f821fe4dd55968a64d3d21f82d87e7a800d25f2da3a72c409c0005fed3926a96744235bd7f4db182205f1c2e55ae97d49655908bba8219174b68d726e6d84255712348f734c39b2c01a2b955c95a289ca0cf01915ad6e610e9158978acab25222566701be6236af5c2d4b921a060d502911356a8ef54db7b416f757f199d9288a0e3037a696c43a08caaeedfc1c1cafc21ddb018268ebbe0890cd402a81a235de42e4b77c48a7d740d6fc01c7a6764353728ebbdaf69abc205499be71ee7958bb296c32624a6db36990a276065e2e32f782ae4c23c7791be977fecad570f8a5a0b8eece137e2eb3700d6b175d2ad07f98854d2e81cbad653ad3cca17d6e84ae6e08da79a298ea8051ef890d839597094a229d8748f8040f0428b497fc300521ecdd85cd2b6f565e20f5219b2c28f0ae7e50f73faa82cc9974c74142af05f3b0809e33f7e51996f97d53c9f1ef9131a960dd7ff00b0a175f09a2b9066d03de945b466fd7be3ce8af1b09db8068441eb32659f064b288f39a40d9d782935bad25dfc5b213fd231a1d0107f0cc2f97a6d6a72a85bc85beda0af842e68d9390a4372e75a99722cd54dad4a787f1e08e7e5b0cc7b5c181e9927e9e9173c22abb131900551a45950f9e1cf534494e269b5e448b9f3090e57912120f916680462ed98c75540fd5b290d8bc17079ee09b3e6de4141dd325413b5f4e49835357917f549723c5d301e2ac8f16495ac0fc6bd75fa3a48663da2bcea4f5d9a713de2b0c59556fe6ee60d00cade8e563b6df1c0217f0d6132b0b7763eb7e31f94a744d01cb40eed30d4e41054ed036646c52df6a5f389121949d9dd7412e1ed1d97069c9b93c5a36d92ad8eb602724389bd6b35bbe2bb3407b601d6308bc5da906a01ec8081a742edd925bc555b7727b3a8ef1e8305da07086cfb00a86a58082aa8aaa01e9376531b9de41910a94aadfc478a1dc774ce69913878d37cdd1b9c69265db8981f44fea31fdcd4a5059464adaea76eef2502c074d830682b249557941dd8e061a5910b44fce90c2955033597df49dd3b3943835e0d94bd819aee5f3eda271df1c710e89f4fd4132b7a69645ab116f6a3806f675217134a3a40dea4208793f5bb9333974a1269cf648c59ed7a4cda78d6deb4d9ca7ed08a5adf1b9d1b379792268c5c1caf1ad87d1d8d6049d87e3b0837036ffc10b84725e39b5605e438cbdc55176839b5f31a8d590c7ea89693754d3ab597a14af2610308516f49dc19719fac11a103ae447745b3920934e68a75c8a9a3385610e716420fdaf852770e5014ebfc274f75342a0407681f6e2f106ebb01cfff7e1044792bd70007d9a611ab916a25128c4653e5f8c81f6c122a49493117cf0df08de3a9b2d7989141c3fd009484a03d732e8f8d0efc5a3abed5d60e6de6fe32d594bab9644fd2efc7d9cef4b24e4b18d73a5537fded1cf9bd12eb43344795ac1efcbaf50f156b311882493b5b3ccddd1fe4f18451859bc7de0a0fe554c9e16eaf61c1262ba2534958e6091e644b16284705b93143a3ce34567a7c1620bf6d987930d563969ac87243de45c25db57dae3ba06e23cdde74006948e9633c12314601903cd13bced2d5acc39e9dc1272a322b7db56cd7e8fb83192e968889ba3509cf04f7513e7dbef958404209b78a615aa81a716933c7154ffdc9b854324e1add71a203c596c45b84c59ab2020c7f95e16179526d5b2ae218126346b74fcb900fe5bd4a2d58dd978ced7f82c2416072162d14cdce10ec879227998a1600e9dc77b9210a3d573959b1f4111efda2f2eed063ba1a265d67906a9732adc26d391fe798407860ef4fc2926c630a56ed9f213636cfb42490878612ee9a8d74670aedd8edc4d81f13af7f2c5207a66e2248071494a3a6d3e44383ed817360e20b7a934537faabf562c279f8221dfb5984d70e3054048e812fa8b40fac46ca6709e40355a91c31044fb4beb653735d3bed8c688339e99b27c38d18785f65d0c6031d8521f759bc4f4164801315fa1e8b7359ea59cfeb39c47e4fb08d5f78ed94090b1f8d60a29a95f7b2658f2b0c7241907cf574efffb39af4f9096b62b1fc9a9e4675398dec3ef10497b560e2647a1096419a8d33c1fde8f2f3c3aa5a96976410b9a1f3ca7ecab9231c8fed357a841cad01aed283f18db55ec9778391085c021d5ba6c4542b32f8ca6caa17a22a3cc49f9e1fac384150453f93c65046a022460be30f91e7349b7070b329ef5996142bcec129aee4a33da6406221953c2a6b8d061457a9f94c53034344ad46b0199d7a3cbac23f1f2e19c9219db303a59147d8c322ee8d3e96ae39c4a3eeb9236c40e106c170c26c643ae885714c14f75d2efdd2b22972993a8569fb6c9f51a87b58498610f0061b68cb5733816a0279df88e3bf396fce3d23c0a71efde7503b4819da05e4bc820e241cc350e24a57ed4a35217ecd5a56c05f87f8e0be16723bc967b5c1345e662bb18d3a0de4d0fafd5c294f85b6e2fe72ff171b995a62dd24c6a58a2d561a7cdc59d982904baaea48545c0552ab46662eb10b968dc734637f93bccfd9e1bd8ac5270a9515290fc494902f6db14ff70575d32077cf87940a15a382d8467d20b0c22f2daecc7242e0442fb5317cfd09f4415429654d8164fd21061d256e8023e9bba6befb9fcd4d954a85d37710b00946aab94dde65fdda0c45099a63b8f18dbf686a4b3f59124c6852a71c45d2b02226fa726e757c6f83563fa39184dc8a4355b67be937a8d45b0a3a8816a005f8caa5a0162171b3edbeea82eaefb9201ae48e54b4dfb5e94a1f426f5ccefd9571cef84a2abe06482bd67a9cdca345fd164470db2a7c1b1653e78595e17960d2e779caf6355b2e4c4d7695974caea6e9ee3eaa5388baf1dad386db4bffa2cdb98769eff61a1bbbb8c24adefde44bc74b1cca287abcb2ab30ac6553440f1a8892a3a5b4317f95defcd36b4cffaeffcabe24b6635087731a6c351e885222bbd05ebdfebcb08eae91b84f94794e59fce0cf22ffabd0bf8a02b4c4dc41cfe119e987c9791c2024c65d83b6357071f9af150eaa32b1815a5fea9d1367490401001817c75e995befde907629857910920b12e38fbed8c0ced972ad585b8fbbf19779c240e1281d768318d011ac5f1037fb69dc56a88efe286df2fb1dc92ab7ebdf0ea5bbd3228dea045af921ad1ec26997be69e5a259e6f6e673a213eba75fba61fa23bf0ceb414c545232c2661aab411d50c386c5a3a9883691314a0e3c8d92375ce24ce159b536b36c72a12b2761a32d1f8c397ac9d77f3f59ecbc94ee168e977ac8bec9a94dd7e4fe9fb8a7d4bfcd1afe06d3b80ac802a634752da1f5848b271252f75eea652347cebcd60ba8ca9b1144185f14707479a6d8f830910bda20f1949a3e552e73094bdb1a0751a4bd71bc167913925e49e6cd2b79fe384ccf11e86c08fc5dd9f82a18fc22dad13468322072708061f1e3ae93892ae8eeb37776cfa1ad5ae7a868ef31683ad2f19f5512878e5762fa1ff6e6581821565c68223d5d6303aa79edab2775a2c5aed756427a02cfa4ab3da55817237d15e8f5570b3655c6a67eedfd416bd74d64cbdc3fcec7ff0800c172583b64cfb7d099f1ddc5ed61398883e10d8d94950ee49c7ddf9195046eee788a4711fde155c029310bde5f4a5e26ef315662dabb17147f5f7b2d71de590da473c7d64d17196ac52f6bb17b258a7a2c0e0dbc1242f43c6bb36ebcbbab332df8e04f6cf24f4765f0428497fe95ff28986c4620a94c61d60094e248d75eca2bb73f6abcc79c1253d4bc9a0cd04df58b8a90cc488fe29cb40eb75b52b16997a0b79ed85e7fb5f9869477a665b3148a4ea70e87b7b675de2e9e5d54a5ece5417b26d903fdef559150be53097883d5afb12e7457ef3658186cdfbaa205bbd5198e5f6c067c844aa6b45abab33b883f4742a4492a1872e5d2eea4b33b218da4a12909b56d6b1a2c0bef21827a787d93ea971adb3214e85ed8e82b5579a50f5f75c433363f4c6029354a1e82d63695fae77275102901afc10bf5d8cbbf494055473b1e7afc00a4d6f21fd31f1f1ad80a0e0adcdc21cb60dc951ef7c5632b7ca3da3f97aba3be415b257fb54250a381e62e419d06967a73cd9667fa9d94e04d030a3452cd07b763a17a6bd3cdaa0300521ddc2f2b9c2a584a134a7d86caba03865e948cd1a1e88920972a7dc09584ab225250b1fbfe94da6737d646b5c32a95aeb45d6ca672fda04e91179f6a54b81ba15275c344159ca57c70490e6de04bf91c3b91e41a8ba552e7e8cf10e9ae8e588d7083f5d47e64e23e8e1715d0cc66eabb033d494b7e4f1cc3bb2b1233376b88e018260b6512db87f179921ae686bc3b4d1f504f5ba2379f0a1d7ab5cdb05448bd80afe4de4eac9aebc509563fea31a58ad97d3d2b079ab3fcd39c6533666485e2df2c0430667762b21efb42eb9e2baf09290b2fbb7440ec2899aa0b76d43cf4393964aff1e213e076817813027c609d0bd61a98b1aa0f2a735fe696a48202335ef6a58b50b500885052794fd18fa3f882f3731c3dba2425cd4f25427b6b224b4c6349cc49a508e4100c36e0fd3d982d74eda82fb5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入你的生日就行啦（8位数哦）</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>一些祝福</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小惊喜喔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础会计复习整理</title>
    <link href="/2024/02/05/%E5%9F%BA%E7%A1%80%E4%BC%9A%E8%AE%A1%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/"/>
    <url>/2024/02/05/%E5%9F%BA%E7%A1%80%E4%BC%9A%E8%AE%A1%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="基础会计"><a href="#基础会计" class="headerlink" title="基础会计"></a>基础会计</h1><h2 id="第一章-总论"><a href="#第一章-总论" class="headerlink" title="第一章 总论"></a>第一章 总论</h2><p>会计是以提供经济信息、提高经济效益为目的的一种管理活动<br>会计体系的基本方法是：核算<br>★会计的基本职能：反映与监督<br>★会计作用的发挥取决于：外部环境因素和内部环境因素<br>会计的双重属性：社会性和技术性<br>会计目标的两种主要学术观点：决策有用观和受托责任观<br>近代会计史的两大里程碑：帕乔利复式簿记著作的出版和会计职业的出现<br>微观会计学的内容是：企业会计和非盈利组织会计<br>应用会计学包括：财务会计、管理会计、审计<br>会计核算的专门办法：设置账户、复式记账、填制和审核凭证、登记账簿、成本计算、财产清查、编制会计报表</p><p>关于反映和监督：<br>     反映职能的三大特征：<br>     1.以货币为计量单位<br>     2.反映过去已经发生的经济活动<br>     3.有连续性、系统性和全面性，体现在记账、算账和报账三个阶段上</p><p>监督职能的三大特征：<br>     1.强制性和严肃性<br>     2.连续性<br>     3.完整性</p><p>会计职能的六职能：<br>     ①反映经济情况<br>     ②监督经济活动<br>     ③核算经济状况<br>     ④描述经济成果<br>     ⑤预测经济前景<br>     ⑥参与经营决策</p><p>会计的具体任务：<br>     ①反映和监督法规、准则、制度的执行情况，维护财经纪律<br>     ②提供会计信息，加强经营管理<br>     ③预测经济前景，参与经营决策<br>     ④反映和监督经营活动和财务收支</p><p>会计作用：<br>     ①为投资者提供财务报告<br>     ②加强经济核算，为企业经营管理提供数据<br>     ③保证企业投入资产的安全和完整<br>     ④为国家进行宏观调控、制定经济政策提供信息</p><h2 id="第二章-会计要素与会计等式"><a href="#第二章-会计要素与会计等式" class="headerlink" title="第二章  会计要素与会计等式"></a>第二章  会计要素与会计等式</h2><p>会计要素是反映会计主体财务状况（资产、负债、所有者权益）和经营成果（收入、费用和利润）的基本单位<br>权益&#x3D;负债（债权人权益）+所有者权益&#x3D;资产<br>对会计对象的具体划分称为会计要素<br>     静态会计等式：资产&#x3D;负债+所有者权益<br>     动态会计等式：利润&#x3D;收入-费用<br>     拓展会计等式：资产&#x3D;负债+所有者权益+利润→资产+费用&#x3D;负债+所有者权益+收入<br>★以下理解即可，记住关键的案例，过一遍眼：</p><h3 id="第一、二节：会计对象和要素"><a href="#第一、二节：会计对象和要素" class="headerlink" title="第一、二节：会计对象和要素"></a>第一、二节：会计对象和要素</h3><p>资产：<br>     （1）以往事项导致的现时权利<br>     （2）资产应为企业拥有或者控制<br>     （3）资产预期会给企业带来经济利益<br>不具备该特征的资源不能再确认为企业资产，如已经报废的房屋、设备等。人力资源也是资产，但是是表外资产，无法计量。<br>判定是否为流动资产的标准是：能否在1年或者超过1年的一个营业周期内变现或者耗用<br>无形资产不包括期权<br>对外投资、拥有某企业的公司债券都算资产</p><p>负债：<br>     （1）负债是由企业过去的交易或者事项形成的现时义务<br>     （2）负债在将来必须以债权人所能接受的经济资源来清偿<br>     （3）负债的清偿预期会导致经济利益流出企业<br>     判定是否为流动负债的标准是：能否在1年或者超过1年的一个营业周期内偿还</p><p>所有者权益：（股东权益、净资产）<br>所有者投入的资本：<br>     （1）实收资本：企业收到投资者按规定投入的法定资本金（假定为100万元）<br>     （2）资本公积：企业收到的投资者超过法定资本金部分的投资(假定实际投入企业资本金为120万元。其中20万元即为资本公积)（IPO）<br>     留存收益：<br>     （3）盈余公积：根据法律规定从实现的利润中提取的暂时留存企业的公积金。<br>     （4）未分配利润：暂未分配的那部分利润。</p><p>★所有者权益与负债的区别：<br>     负债：是企业对债权人所承担的经济责任，企业负有偿还的义务；债权人只享有按期收回利息和债务本金的权利，而无权参与企业的利润分配和经营管理；在企业清算时，负债拥有优先求偿权<br>     所有者权益：是企业对投资人所承担的经济责任，在一般情况下是不需要归还给投资者的；投资者则既可以参与企业的利润分配，也可以参与企业的经营管理；所有者权益则只能在清偿了所有的负债以后，才返还给投资者<br>     （二者偿还期不同√）</p><p>收入：<br>     （1）收入应当是企业在日常活动中形成的<br>     （2）收入应当会导致经济利益的流入，该流入不包括所有者投入的资本<br>     （3）收入应当最终会导致所有者权益的增加<br>     不会导致所有者权益增加的经济利益流入不属于收入！如企业向银行借款、预收客户货款等。</p><p>收入的组成：<br>     （1）主营业务收入是指企业从事的日常主要业务获取的收入（如汽车制造企业销售汽车收入、电脑生产企业销售电脑收入等）。<br>     （2）其他业务收入是指企业发生的日常其他业务所产生的收入（如产品生产企业处理其多余积压材料收入，汽车制造企业销售其汽车配件收入、就计算机生产企业销售其电脑配件收入等）。<br>     （3）投资收益是指企业对外投资（如购买其他企业的股票、债券）活动获取的股利、利息收入。<br>     （4）营业外收入是指企业在非日常活动中偶尔发生的经济利益流入。包括政府补贴收入、收到被罚款方交来的罚款收入等。</p><p>利得：（区分于收入）<br>     指由企业非日常活动所形成的、会导致 所有者权益 增加的、与所有者投入资本无关的经济利益的流入。不是所有的利得和损失都应该计入当期损益。</p><p>费用：<br>     （1）费用应当是企业在日常活动中发生的<br>     （2）费用应当会导致经济利益的流出，该流出不包括向所有者分配的利润<br>     （3）费用应当最终会导致所有者权益的减少<br>不会导致所有者权益减少的经济利益流出不属于费用！如用存款购买设备等。<br>费用含有生产费用（直接材料、直接人工、制造费用）和期间费用（管理、财务、销售费用）<br>★成本与费用的区别：</p><p>成本：<br>     （1）指企业为生产产品、提供劳务而发生的各种耗费<br>     （2）是与产品相联系的<br>     （3）要有实物承担者<br>费用：<br>     （1）是指企业在日常活动中发生的营业税费、期间费用和资产减值损失<br>     （2）与期间相联系的<br>     （3）一般没有实物承担者</p><p>利润：<br>是所有收入与所有费用（成本×）配比相抵后的差额，是经营成果的最终要素<br>净利润≠营业利润-所得税</p><h3 id="第三节-会计等式"><a href="#第三节-会计等式" class="headerlink" title="第三节  会计等式"></a>第三节  会计等式</h3><p>★关于会计等式一些不太清楚的点：<br>     1.负债与所有者权益项目的此增彼减；<br>     从税后利润中提取福利费，尚未发放；宣告分配现金股利，尚未支付；债转股<br>     2.资产与所有者权益项目的同增；<br>     投资者以固定资产作为资本投入<br>     3.所有者权益项目之间的此增彼减；<br>     资本公积转增资本；盈余公积转增资本；提取盈余公积<br>     4.收入与资产同增<br>     销售商品，收到货款存入银行；销售商品，货款尚未收到（销售了收没收到钱收入都增加）<br>     5.收入与负债此增彼减<br>     6.7月预收货款，8月发货时</p><h2 id="第三章-会计核算基础"><a href="#第三章-会计核算基础" class="headerlink" title="第三章 会计核算基础"></a>第三章 会计核算基础</h2><h3 id="第一节-会计基本前提：会计假设"><a href="#第一节-会计基本前提：会计假设" class="headerlink" title="第一节  会计基本前提：会计假设"></a>第一节  会计基本前提：会计假设</h3><p>会计四大假设：<br>1.会计主体假设（明确空间范围）<br>“企业应当对其本身发生的交易或者事项进行会计确认、计量和报告。”注意企业本身不包括企业经营者个人的财务收支。如：★★★一个（非）营利性组织、（不）具备法人资格的实体<br>法律主体与会计主体的区别：<br>一般而言，法律主体必然是一个会计主体；但有些会计主体不一定是法律主体。例如某些企业集团就是如此。★★★企业集团是会计主体不是法律主体，合营企业、子公司、有限责任公司都是既是会计主体又是法律主体<br>2.持续经营假设（明确时间范围）<br>3.会计分期假设<br>★★★企业的会计期间是人为划分的<br>4.货币计量假设</p><h3 id="第二节-会计信息质量特征："><a href="#第二节-会计信息质量特征：" class="headerlink" title="第二节  会计信息质量特征："></a>第二节  会计信息质量特征：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.可靠性（如实反映，不做假账）<br>2.相关性（也叫有用性，可以预测价值、反馈价值）<br>3.可理解性（明晰性）<br>4.可比性（同一企业不同时期对比；不同企业（同行）同一时期对比）注意：对比要用同一种方法。存货发出<br>★★★对相关性和可靠性起着制约作用<br>★★★企业进入破产清算时按照可比性会计信息质量不能按照原有的会计程序与方法<br>5.实质重于形式（按照交易或者事项的经济实质进行会计确认、计量和报告）<br>★★★对于企业经营租入设备，经济实质与法律形式统一，所有权、处置权在出租方，使用权在承租方<br>对于企业融资租入设备，经济实质与法律形式不统一，法律形式同上，而经济实质所有权、处置权、使用权都在承租方（从承租开始就属于承租方了）。（租入设备）<br>6.重要性（帮忙分个主次）<br>7.谨慎性（稳健性、保守性，提前确认费用负债，推迟确认收入）坏账准备<br>存货的期末计价—成本与可变现净值（假定销售）孰低法，可变现净值低于成本时调整账面，高于成本时不调整账面<br>8.及时性（按规定的时间及时进行报告每年4月30日要出前一年的报表）<br></code></pre></td></tr></table></figure><p>错题：收益性支出计入到资本性支出，费用减少，利润增加</p><h3 id="第三节-会计要素确认、计量及其要求"><a href="#第三节-会计要素确认、计量及其要求" class="headerlink" title="第三节  会计要素确认、计量及其要求"></a>第三节  会计要素确认、计量及其要求</h3><p>会计的基本程序指的是会计的数据处理与加工信息的程序。<br>理论上：确认→计量→记录→报告<br>实务上：证→账→表</p><p>会计确认：<br>1.初始确认条件（记入账户）<br>（1）符合要素定义；<br>（2）有关经济利益很可能（50%以上）流入（资产、收入）或流出（负债、费用）企业；<br>（3）有关成本或价值能够可靠计量。（人力资源无法可靠的计量所以不能确认）</p><p>2.最终确认条件（列入报表）<br>（1）符合要素定义；（2）符合要素确认条件。二者必需同时具备，缺一不可！</p><p>会计计量：<br>1.计量单位：以货币作为主要计量单位<br>★★★有至少两种形式：名义货币单位和不变货币单位等<br>★★★不是所有企业的会计核算都必须以人民币作为记账本位币<br>2.属性及其构成：<br>（1）历史成本——实际支付<br>★★★财产物资计价的原则是历史成本原则<br>（2）重置成本——按当前市场价重新购买一个一模一样的价格（折旧之类的因素要算在其中）<br>（3）可变现净值——出售<br>（4）现值——假定持有。是指未来现金流量以恰当的折现率进行折现后的价值，是考虑货币时间价值的一种计量属性。<br>（5）公允价值（你情我愿）。是指资产和负债按照市场参与者在计量日发生的有序交易中，出售资产所能收到或者转移负债所需支付的价格计量。有序交易：是指在计量日前一段时期内相关资产或负债具有惯常市场活动的交易。清算等被迫交易不属于有序交易。即银行拍卖不是按照公允价值的。</p><p>会计要素进行计量时一般采用历史成本（企业不得私自调账），股票一般用公允价格<br>★★★历史成本的优点：交易确定的金额比较客观、有原始凭证做证明可随时查证、可防止企业随意改动、会计核算手续简化，不必经常调整账目。（存货成本接近市价×）<br>★★★支出的效益只与本会计年度有关的为收益性支出，与几个会计年度有关的为资本性支出（固定资产、无形资产、递延资产）。在会计年度内，如果把收益性支出当作资本性支出处理了，则会导致本年度虚增资产和收益<br>★★★配比原则是指收入与其相关的成本费用相配比</p><h3 id="第四节-收付实现制与权责发生制"><a href="#第四节-收付实现制与权责发生制" class="headerlink" title="第四节 收付实现制与权责发生制"></a>第四节 收付实现制与权责发生制</h3><p>收付实现制：<br>也称现收现付制或现金制，是以款项是否实际收到或付出作为确定本期收入和费用的标准。确认标准：以实际收到、实际付出为标准（收支期）</p><p>权责发生制（会计只用这个）：<br>确认收入和费用的标准：应收应付。以实际受益为准。（是否有权取得或是否受益）<br>强调经营成果计算的企业适合采用权责发生制</p><h2 id="第四章-账户与复式记账"><a href="#第四章-账户与复式记账" class="headerlink" title="第四章 账户与复式记账"></a>第四章 账户与复式记账</h2><h3 id="第一节-账户与会计科目"><a href="#第一节-账户与会计科目" class="headerlink" title="第一节 账户与会计科目"></a>第一节 账户与会计科目</h3><p>会计科目是账户的名称。<br>账户是根据会计科目设置的，具有一定的结构，用以系统、连续地记录经济业务的工具。</p><p>★会计科目与会计账户的区别<br>会计科目：<br>通常由国家统一规定，是各单位设置账户、处理账务的依据，是会计要素具体内容进行分类的项目名称，本身没有结构<br>账户：<br>由各会计主体自行设置，是会计核算的重要工具，不仅表明经济内容，还具有一定的结构格式，能够反映资金运动状况<br>★★★账户的基本结构：1.账户名称2.会计事项发生的日期3.摘要4.凭证号数5.金额   T形账户实际是不用的，只在会计的教学中使用</p><p><img src="/pic/01.png" alt="img"></p><p>★★★账户金额的基本结构：1.期初余额2.本期增加额3.本期减少额4.期末余额（余额一般在增加方）</p><h3 id="第二节-复式记账原理"><a href="#第二节-复式记账原理" class="headerlink" title="第二节  复式记账原理"></a>第二节  复式记账原理</h3><p>★单式记账法简介：<br>通常只对货币资金（即库存现金和银行存款）收付、债权债务（即应收账款和应付账款）结算涉及的账户加以记录，而对实物增减涉及的资产账户等则不予记录（当然也不设置这些账户）。<br>特点：1.实物性资产的结存数额通过实地盘点得到<br>2.利润通过比较期末与期初的资产结存<br>3.单式记账法手续简单，但是不能全面反映各项经济业务的来龙去脉，也不能正确核算成本与盈亏，更不便于检查账户记录的正确性。因此很少采用。</p><p>★复式记账法简介：<br>运用会计方法把两个或两个以上方面的变动加以全面记录，即复式记账。<br>理论依据：资金运动的内在规律性：任何经济业务都会涉及两个或两个以上的方面<br>特点：<br>1.需要设置完整的账户体系（实物性资产、收入、费用等），并做全面、系统的反映<br>2.通过两个或多个账户，同时如实反映所涉及的两个或多个方面，反映资金运动的来龙去脉<br>3.根据会计等式的平衡关系进行试算</p><h3 id="第三节-借贷记账法"><a href="#第三节-借贷记账法" class="headerlink" title="第三节   借贷记账法"></a>第三节   借贷记账法</h3><p>产生：大约在12～13世纪起源于商业经济比较发达的意大利，总结于14世纪末，并逐渐流传于全世界。<br>★记账符号：“借（Dr）”和“贷（Cr）”<br>★借贷记账法的账户结构：（借&#x2F;贷记卡的主体是自己）<br>资产和费用类增加在借方，其他的都在贷方。<br>★借贷记账法的记账规则：有借必有贷，借贷必相等<br>★借贷记账法的试算平衡：<br>全部账户借方发生额&#x3D;全部账户贷方发生额<br>全部账户借方余额&#x3D;全部账户贷方余额</p><p><img src="/pic/02.png" alt="img"></p><p><img src="/pic/03.png" alt="img"></p><h2 id="第五章企业主要经济业务的核算★★★★★"><a href="#第五章企业主要经济业务的核算★★★★★" class="headerlink" title="第五章企业主要经济业务的核算★★★★★"></a>第五章企业主要经济业务的核算★★★★★</h2><h3 id="第一节企业的主要经纪业务概述"><a href="#第一节企业的主要经纪业务概述" class="headerlink" title="第一节企业的主要经纪业务概述"></a>第一节企业的主要经纪业务概述</h3><p>1.资金筹集业务；<br>2.供应过程业务；<br>3.生产过程业务；<br>4.销售过程业务；<br>5.财务成果形成与分配业务等。</p><h3 id="第二节-资金筹集业务的核算（所有者权益-负债资金）"><a href="#第二节-资金筹集业务的核算（所有者权益-负债资金）" class="headerlink" title="第二节 资金筹集业务的核算（所有者权益+负债资金）"></a>第二节 资金筹集业务的核算（所有者权益+负债资金）</h3><p>1.所有者权益资金筹集业务的核算：<br>★账户：实收资本（在股份制公司里面叫做股本，是指企业的投资者按照企业章程或合同、协议的约定实际投入企业的资本金。）、资本公积（资本在投入过程中产生的溢价等，所有权属于投资者，可以转为实收资本）<br>实收资本的分类：<br>按投资主体划分（国家、法人、个人、外商资本金）<br>按投资形式划分（货币资金投资、非货币资产投资）<br>★计算盈余公积：<br>融资&#x3D;发行股票数×每股发行价<br>股本&#x3D;发行股票数×每股面值（一般是1元）<br>资本公积&#x3D;发行股票数×差价</p><p>2.负债资金筹集业务的核算：<br>★账户：短期借款、财务费用、应付利息、长期借款、在建工程、工程物资（看个人，可以不用）、固定资产<br>★短期借款的核算：<br>偿还期限在一年以内，用途：满足企业生产经营临时周转需要。如购买材料、偿付债务等。<br>利息的确认（权责发生制度）：短期借款利息属于企业在资金筹集过程中发生的费用性支出，一般应按月确认为借款使用期间的财务费用。（借款利息＝借款本金×利率×时间（按月、日））<br>利息的支付方式和账务处理方法：①按月度支付，直接计入当期损益。②按季度或半年支付，或一并收回利息，但利息数额较大时，按月预提借款利息。<br>分录：利息的计算：<br>（没给钱）借：财务费用 贷：应付利息<br>（给这个月的）借：财务费用 贷：银行存款<br>（给上个月的）借：应付利息 贷：银行存款</p><p>★长期借款业务的核算：<br>偿还期一般在一年以上，用途：满足企业进行固定资产购建的需要。如购买设备、建造厂房等。在建设时，利息计入在建工程；完工后，利息计入财务费用</p><p>★★★分录：利息的支付方式和账务处理方法：<br>①一次还本付息：每月计提时：借：在建工程&#x2F;财务费用（看是否建完） 贷：长期借款<br>到期还款时：借：长期借款 贷：银行存款<br>②分期付息，到期还本：每月计提时：借：在建工程&#x2F;财务费用（看是否建完） 贷：应付利息<br>                      到期还款时：借：应付利息、长期借款 贷：银行存款<br>计算xxxxx→计提</p><h3 id="第三节供应过程业务的核算（材料采购和设备购置）"><a href="#第三节供应过程业务的核算（材料采购和设备购置）" class="headerlink" title="第三节供应过程业务的核算（材料采购和设备购置）"></a>第三节供应过程业务的核算（材料采购和设备购置）</h3><p>★★★★★第一部分：材料采购业务<br>账户：实际成本法：在途物资、原材料<br>      计划成本法：材料采购、材料成本差异、原材料<br>      结算方式：应付账款，预付账款，应付票据、应交增值税·····<br>★★★关于应交增值税：<br>增值税税率：一般为13%。进项税额＝买价×税率 销项税额＝销售额×税率               企业当期应纳税额＝销项税额－进项税额；小规模纳税人为3%，不能抵扣</p><p>★材料采购业务的核算：<br>购买价款（供货单位的发票价格）<br>运杂费（运输费、包装费、装卸费、保险费、仓储费等分配后计入具体材料）<br>运输途中的合理损耗<br>入库前的整理挑选费用<br>各种税金（关税、消费税以及不能抵扣的增值税进项税额等，不包括能够抵扣的增值税进项税额）所以一般增值税的进项税额不算<br>其他费用（大宗物资的市内运杂费等，但市内零星运杂费、采购人员差旅费等计入期间费用）</p><p>★材料采购业务核算的两种方法：实际成本法和计划成本法<br>实际成本适用于经营规模较小、原材料种类不多、收发业务不频繁的企业。<br>注意：1.相关税金有两种：已取得增值税专用发票的为价外税，记入“应交税费”账户；其余税金（如进口关税等）为价内税，计入采购成本，记入“在途物资”账户。<br>2小额零星采购费（如市内运输费）不计入采购成本，可计入管理费用。<br>按计划成本计价：在日常收、发材料时均采用计划成本，而不是实际成本。<br>材料成本差异额＝实际成本－计划成本 结果为正数时是超支额（借差）；为负数时是节约额（贷差）</p><p>★★★分录：<br>实际成本法：<br>购买：借：在途物资（实际成本） 应交税费—应交增值税（进项税额） 贷：银行存款····<br>入库：借：原材料（实际成本）贷：在途物资<br>发出：借：生产成本（实际成本）贷：原材料</p><p>计划成本法：<br>购买：借：材料采购（实际成本）应交税费—应交增值税（进项税额） 贷：银行存款····<br>入库：借：原材料（计划成本） 贷：材料采购 （实际成本）<br>材料成本差异补差价&#x3D;实际成本（包括运费什么的）-计划成本单价×实际收到的数量<br>发出：借：生产成本（计划成本） 贷：原材料</p><p>关于材料发出<br>材料成本差异率：月初结存材料成本差异+本月收入材料成本差异&#x2F;月初结存材料计划成本+本月收入材料计划成本×100%<br>发出时应分配的差异额：发出的计划成本×材料成本差异率</p><p>★★★例题：假定甲材料月初的计划成本为50 000元，节约差为3 000元；本月购入甲材料计划成本54 000元，超支差1 200元。发出甲材料计划成本65 000元。<br>解：计算出差异率为-1.7%，再计算出差异额为-1105元。<br>发货分录：借：生产成本 贷：原材料<br>          借：生产成本（金额用红字） 贷：材料成本差异（金额用红字）<br>★★★注意：第二部分的借和贷账户固定，若为超值额则金额用黑字写；若为节约额则金额用红字写。计算发货的实际成本时，黑字加红字减。</p><p>第二部分：设备购置<br>账户：固定资产，在建工程，应交税费—应交增值税（进项税额）</p><p>固定资产的定义：<br>1.为生产商品、提供劳务、出租或经营管理而持有；（不是为出售而持有！）<br>2.使用寿命超过一个会计年度。<br>设备购置的实际成本&#x3D;买价+运输费+包装费+安装费+借款利息等（进项税额一般不计入）</p><p>★确认固定资产：对建造固定资产已达到预定可使用状态（不管是否办理竣工决算，实质重于形式的体现），即可按估计价值入账。包括人工、材料和机械费等成本。</p><p>分录：借：在建工程&#x2F;固定资产 应交税费—-应交增值税（进项税额）贷：····</p><h3 id="第四节-生产过程业务的核算"><a href="#第四节-生产过程业务的核算" class="headerlink" title="第四节  生产过程业务的核算"></a>第四节  生产过程业务的核算</h3><p>第一部分：材料费用的归集与分配<br>生产成本和生产费用的关系：1.前者与会计对象相关；后者与会计期间相关2.生产费用是产品成本形成的基础。生产费用发生过程也是产品成本的形成过程。<br>生产成本：（直接费用）<br>直接材料（生产产品消耗的材料费等）和直接人工（生产工人工资及福利费等）</p><p>第二部分：人工费用的归集与分配<br>应付职工薪酬包括：<br>1.短期薪酬<br>职工工资、奖金、津贴和补贴<br>职工福利费<br>社会保险费<br>医疗、养老、失业、工伤和生育<br>住房公积金<br>工会经费和职工教育经费（计提分别不能超过2%和8%）<br>短期带薪缺勤<br>短期利润分享计划<br>其他短期薪酬<br>2.离职后福利<br>3.辞退福利<br>4.其他长期职工福利</p><p>★★★工资的归集：<br>生产工人→生产成本、在建工程<br>车间管理&#x2F;技术&#x2F;xxxx人员→制造费用<br>企业管理&#x2F;xxxx部门→管理费用</p><p>★★★代付代缴的分录：<br>个人：<br>计提：借：生产成本&#x2F;制造费用&#x2F;管理费用 贷：应付职工薪酬<br>发放：借：应付职工薪酬 贷：其他应付款<br>缴纳：借：其他应付款 贷：银行存款·····<br>单位：<br>计提：借：管理费用 贷：其他应付款<br>缴纳：借：其他应付款 贷：银行存款·····</p><p>第三部分 制造费用的归集与分配<br>账户：制造费用、长期待摊费用、累计折旧<br>制造费用的含义：企业的生产管理部门（如生产车间）为组织和管理产品生产活动而发生的各种间接费用。包括车间管理人员工资、办公费和设备使用费等。制造费用是间接费用，月末要全部结转成生产成本<br>长期待摊费用：1年以上，如预付的房租、保险费、设备大修理费等</p><p>分录（假如预付房租）：<br>支付时：借：长期待摊费用 贷：·······<br>每月计提时：借：xx费用 贷：长期待摊费用<br>累计折旧：增加在贷方。固定资产清理时，固定资产和累计折旧同时减少，期末余额在贷方<br>价值&#x3D;原值-固定资产减值准备-累计折旧<br>固定资产折旧性质：固定资产在使用过程中的价值损耗。提取折旧的目的是为了用于固定资产更新。<br>折旧的计算提取方法：每月末，根据下列公式计算，并按照固定资产用途分别计入当月成本或费用。<br>每月计提折旧额＝固定资产账面原值（历史成本）×选定的折旧方法所确定的折旧率<br>折旧核算上的特殊做法：设立“累计折旧”账户，专门记录已计提的折旧额（而不是直接记入“固定资产”账户贷方）不同部门的设备借方的账户不同</p><p>第四部分  完工产品生产成本的计算与结转<br>设置账户：生产成本、库存商品<br>★★★项目的构成：直接材料、直接人工、制造费用（即不计累计折旧和管理费用）<br>两个等式：<br>期末余额&#x3D;期初余额+本期增加额-本期减少额<br>★完工成本&#x3D;月初在产品+本期投入-月末在产品<br>分录：借：库存商品    贷：生产成本<br>错题：<br>支票计入的是银行存款<br>★★★车间管理人员出差的分录：（从公司的角度出发）<br>给钱时：借：其他应收款 贷：银行存款&#x2F;·····<br>回来报销时若省下钱：借：制造费用 库存现金&#x2F;···  贷：其他应收款<br>回来报销时若超支：借：制造费用（采购人员则写管理费用） 贷：其他应收款  银行存款&#x2F;库存现金·····<br>金融机构的费用计入财务费用</p><h3 id="第五节-销售过程业务的核算（收和支分开核算）★★★★★"><a href="#第五节-销售过程业务的核算（收和支分开核算）★★★★★" class="headerlink" title="第五节   销售过程业务的核算（收和支分开核算）★★★★★"></a>第五节   销售过程业务的核算（收和支分开核算）★★★★★</h3><p>第一部分  主营业务收支的核算<br>设置账户：主营业务成本（生产成本结转过来的）、主营业务收入、税金及附加（不包括增值税和所得税）、销售费用</p><p>主营业务收入的确认：<br>1.识别与客户订立的合同<br>2.识别合同中的单项履约义务<br>3.确定交易价格<br>4.将交易价格分摊至各单项履约义务<br>5.履行每一单项履约义务时确认收入（谨慎性）</p><p>销售费用：<br>属于期间费用，垫付运费、专设销售机构、销售人员的各项费用、广告费、或包装费等的费用计入销售费用。但是，销售部门的费用计入管理费用。<br>分录：（收支两条线）<br>（收，只知道售价）借：银行存款··· 贷：主营&#x2F;其他业务收入 应交税费——应交增值税（销项税额）<br>（支，只知道成本）借：主营&#x2F;其他业务成本   贷：库存商品</p><p>主营业务成本：<br>为取得主营业务收入而发生的商品成本（即产品的生产成本，也是被销售库存商品的成本。其中，不包括发生的产品销售费用等。<br>Notice:若本期销售的产品是多批次生产的，其单位成本又各不相同，应采用先进先出法、一次加权平均法或个别计价法等确认其单位成本（第十章）<br>税金及附加的分录：（易错）借：税金及附加 贷：应交税费</p><p>第二部分  其他业务收支的核算<br>设置账户：其他业务收入、其他业务成本<br>内容：<br>企业在日常经营活动中发生的主营业务以外的其他业务收入和成本。如销售材料、出租包装物和固定资产等实现的收入和发生的成本。其他业务与主营业务都属于企业的日常经营活动业务。但实现其他业务收入、发生其他业务成本应设置专门的账户进行核算。</p><h3 id="第六节-财务结果形成与分配业务核算"><a href="#第六节-财务结果形成与分配业务核算" class="headerlink" title="第六节  财务结果形成与分配业务核算"></a>第六节  财务结果形成与分配业务核算</h3><p>第一部分 财务成果的基本含义（过）<br>企业在一定会计期间所实现的最终经营成果，即实现的利润或发生的亏损总额。<br>设置账户：管理销售财务费用、营业外收支、投资收益、所得税费用、本年利润、利润分配、应付股利、盈余公积</p><p>第二部分  利润的构成与计算公式<br>利润总额&#x3D;营业利润＋营业外收入－营业外支出<br>其中营业利润&#x3D;营业收入－营业成本－税金及附加－销售费用－管理费用－财务费用－资产减值损失±公允价值变动净损益±投资净损益±资产处置净损益（过）<br>净利润&#x3D;利润总额-所得税费用<br>计提所得说：借：所得税费用  贷：应交税费——应交所得税<br>结转所得税：借：本年利润  贷：所得税费用<br>算出净利润后制作分录：<br>借：本年利润   贷：利润分配——未分配利润</p><p>第三部分  营业利润形成过程的核算<br>期间费用：管理费用、销售费用、财务费用。在发生以后不能直接归属于某种特定产品成本，而应直接计入发生期损益（费用）的各种费用。<br>投资收益（净收益或净亏损）：企业用其资金购买债券、股票等对外投资获得的收益（或产生的损失）。期末转到本年利润<br>交易性金融资产（买卖成本）：资产类。借方为尚未出售的交易性金融资产的市值，贷方为交易性金融资产的出售及减值</p><p>第四部分  净利润形成过程的核算<br>设置账户：营业外收支、所得税费用、本年利润<br>营业外收支：也称为利得和损失。营业外收入：包括报废毁损非流动资产利得、债务重组利得、政府补助、流动资产盘盈利得和接受捐赠利得等（固定资产清理后的收入计入营业外收入，此时累计折旧和固定资产同时减少）。营业外支出：包括非流动资产报废毁损损失、债务重组损失、非常损失（自然灾害之类的）、盘亏损失和公益性捐赠支出等。<br>Notice：如果资产处置后还有使用价值，则计入“资产处置损益”科目，反之，则计入“营业外支出”或“营业外收入”科目。<br>例如，固定资产毁损报废后，不再有使用价值，应计入营业外收支科目。</p><p>所得税费用：应交所得税额&#x3D;利润总额×所得税税率</p><p>本年利润：包含了主营业务收支、其他业务收支、营业外收支、期间费用、税金及附加、所得税费用、投资收益。借方为收入，贷方为费用。制作分录时一般先不算所得税费用，先将其他的收入和费用结转到本年利润，算出利润总额，再利用利润总额计算所得税，然后再将所得税结转到本年利润算出净利润。</p><p>关于收入和费用账户结转时间及期末余额情况说明（过）<br>1.账结法：每月末结转，通过“本年利润”账户计算当月实现利润；以上收入和费用账户没有余额；<br>2. 表结法：年末一次结转，各月通过编制“利润表”计算当月实现利润；以上收入和费用账户1～11月末有余额；12月末结转后应无余额。</p><p>第五部分  利润分配业务的核算<br>利润分配的含义：企业根据法律、董事会等决议提请股东大会批准，对企业可供分配利润指定其特定用途，或分配给投资者的行为。包括企业按规定提取法定公积金和分配给投资者等。<br>顺序为先补亏，再提取盈余公积，加上去年的余款或者提取出来的盈余公积进行分配，分配完后的未分配利润留到下一年。年末应当结清利润分配（除未分配利润外的账户）<br>未分配利润&#x3D;可供投资者分配的利润-优先股股利-普通股股利<br>设置账户：利润分配——提取法定盈余公积<br>——提取任意盈余公积<br>——应付现金股利<br>——转作资本的股利<br>——转作股本的股利<br>——盈余公积补亏<br>——未分配利润<br>盈余公积——法定盈余公积<br>        ——任意盈余公积<br>应付股利、应付利润（要看时什么类型的公司）<br>Notice：企业宣告分配现金股利会形成负债，借：利润分配——未分配利润 贷：应付股利&#x2F;利润；而宣告分配股票股利时，没有资产的流出，所以属于所有者权益的改变，借：利润分配——未分配利润 贷：实收资本&#x2F;股本。</p><p>分配时有两个分录：<br>例如：（分配时）借：利润分配——提取法定盈余公积  贷：盈余公积——法定盈余公积<br>      （结清时）借：利润分配——未分配利润 贷：利润分配——提取法定盈余公积</p><p>错题：<br>1.将无法偿还的应付款予以转账 借：应付账款  贷：营业外收入<br>2.报销职工差旅费  借：管理费用  贷:库存现金&#x2F;银行存款····<br>3.计算所得税并结转&#x3D;计提并结转，两个分录：<br>借：所得税费用  贷：应交税费——应交所得税<br>借：本年利润  贷：所得税费用<br>4.用现金购买印花税票  借：税金及附加（不用应交税费）      贷：库存现金<br>5.定额损耗和日常收发计量差错、业务招待费计入管理费用<br>6.计提应由本月负担的银行借款利息 980元 借：财务费用 贷：应付利息<br>7.公司购进甲材料1800千克，含税单价9.04 元&#x2F;千克，丙材料1500千克，含税单价 5.65 元&#x2F;千克，增值税税率为 13%，款项均已通过银行付清，另外供应单位代垫运费3 300元(按重量分配)。借：材料采购 应交税费 贷：银行存款 应付账款<br>8.公司按各类人员工资数额的14%计算提取职工福利费。借：生产成本 贷：应付职工薪酬<br>9.生产车间水电费、固定资产折旧费计入制造费用</p><h2 id="第六章-账户的分类（看看对应关系即可）简单过一遍（调整账户）"><a href="#第六章-账户的分类（看看对应关系即可）简单过一遍（调整账户）" class="headerlink" title="第六章  账户的分类（看看对应关系即可）简单过一遍（调整账户）"></a>第六章  账户的分类（看看对应关系即可）简单过一遍（调整账户）</h2><p><img src="/pic/04.png" alt="img"></p><h3 id="第三节-账户按用途和结构分类"><a href="#第三节-账户按用途和结构分类" class="headerlink" title="第三节   账户按用途和结构分类"></a>第三节   账户按用途和结构分类</h3><p> (一)盘存账户<br>        盘存账户是用来核算、监督各项财产物资和货币资金(包括库存有价证券)的增减变动及其实有数的账户。如：“库存现金”、“银行存款”、“原材料”、“库存商品”、“固定资产”等账户。<br>★特点：可以通过财产清查的方法，即实地盘点和对账的方法，核对货币资金和实物资产的实际结存数与账面结存数是否相符，并检查其经营管理上存在的问题。<br>（二）投资收益账户<br>核算投资者投资的增减变动及实有额的账户，它是任何企业单位都必须设置的基本账户。包括实收资本、资本公积、盈余公积等。<br>（三）结算账户<br>用来核算和监督企业与其他单位或个人之间往来账款结算业务的账户。分为：债权（应收账款、其他应收款、应收票据、预付账款等）、债务（应付账款、其他应付款、应付职工薪酬、应交税费等）、债券债务（应付应收账款、预付预收账款）<br>（四）跨期摊配账户<br>长期待摊费用<br>(五)抵减账户<br>  抵减账户亦称备抵账户，是用抵减相关被调整账户金额的方法，反映被调整账户的实际余额的账户。如：累计折旧、“资产减值准备”突然降价、“坏账准备”等<br>固定资产原值&#x3D;原始价值、历史成本<br>固定资产净值&#x3D;原值-累计折旧<br>固定资产账面价值&#x3D;原值-累计折旧-减值准备<br> (六)抵减附加账户<br>抵减附加账户亦称备抵附加账户，是既用来抵减，又用来增加被调整账户的余额，以求得被调整账户的实际余额的账户。如：材料成本差异<br>(七)集合分配账户<br>汇集间接费用。如：制造费用<br> (八)成本计算账户<br>用来核算和监督经营过程中应计入特定成本计算对象的经营费用，并确定各成本计算对象实际成本的账户。如：“材料采购”、“在途物资”、“生产成本”等账户。<br>(九)对比账户<br>按照两种不同的计价标准进行对比，借以确定其业务成果的账户。如：材料采购<br>(十)收入计算账户<br>收入<br>(十一)费用计算账户<br>各项费用<br>(十二)财务成果计算账户<br>本年利润和利润分配<br>十三、按账户与会计报表关系的分类<br>资产负债表：资产、负债、所有者权益<br>利润表：收入、费用、利润</p><h2 id="第七章-成本计算（简单过一遍）"><a href="#第七章-成本计算（简单过一遍）" class="headerlink" title="第七章 成本计算（简单过一遍）"></a>第七章 成本计算（简单过一遍）</h2><h3 id="第一节-成本计算的意义、原理与要求"><a href="#第一节-成本计算的意义、原理与要求" class="headerlink" title="第一节    成本计算的意义、原理与要求"></a>第一节    成本计算的意义、原理与要求</h3><p>成本的定义：成本是属于价值的范畴，是新增（或已耗）资产价值的组成部分。<br>    新增资产：企业新生产出来的产品等。<br>已耗资产：在生产过程中的消耗等。<br>意义：<br>1.计量经营耗费和确定补偿尺度的重要工具<br>2.决定商品价格的基础和产品竞争能力的条件<br>3.企业进行经营决策，核算经济效益的重要因素<br>4.衡量企业管理水平和各方面工作的综合指标<br>成本计算的重要性原理：<br>对少量的不影响受益对象成本计算的费用可不计入受益对象成本如：★如购入材料的市内零星运费、车间设备修理费可计入“管理费用”（小金额）</p><p><img src="/pic/05.png" alt="img"></p><h3 id="第二节-成本计算的一般程序"><a href="#第二节-成本计算的一般程序" class="headerlink" title="第二节  成本计算的一般程序"></a>第二节  成本计算的一般程序</h3><p>略,前面提到过了</p><h3 id="第三节企业经营过程中的成本计算（略）"><a href="#第三节企业经营过程中的成本计算（略）" class="headerlink" title="第三节企业经营过程中的成本计算（略）"></a>第三节企业经营过程中的成本计算（略）</h3><p>★供应：原材料采购成本<br>★生产：（完工）产品生产成本<br>★销售：产品销售成本<br>★原材料采购根据重要性原理，企业发生的与材料采购有关的一些零星小额、对材料采购成本的计算影响不大的支出，可以不计入原材料采购成本，而是作为期间费用处理，列入管理费用。<br>可以不计入原材料采购成本，而是作为期间费用处理的支出包括：材料供应部门或材料仓库所发生的经常性费用、采购人员的差旅费、采购机构经费，以及发生在市内的小额运杂费等。<br>原料成本：略<br>生产成本&#x3D;期初+期末-本期投入<br>销售成本加权计算：<br>总销售成本&#x2F;总数&#x3D;销售成本</p><h2 id="第八章-会计凭证（只考第一节）"><a href="#第八章-会计凭证（只考第一节）" class="headerlink" title="第八章  会计凭证（只考第一节）"></a>第八章  会计凭证（只考第一节）</h2><h3 id="第一节-会计凭证的作用和种类"><a href="#第一节-会计凭证的作用和种类" class="headerlink" title="第一节  会计凭证的作用和种类"></a>第一节  会计凭证的作用和种类</h3><p>会计凭证的含义：会计凭证是记录经济业务，明确经济责任，据以登记账簿的书面证明。包含：1.主要记录经济业务发生时间、内容等；2.经办人员需签名或盖章，以便明确经济责任3.登记账簿的依据<br>作用：<br>1.提供经济业务原始资料的重要载体<br>2.登记账簿的必要依据<br>3.明确经济责任的主要手段<br>4.实行会计监督的具体措施</p><p>·会计凭证的种类：原始凭证和记账凭证<br>·原始凭证：经济业务发生时取得或填制的，内容为载明业务内容和完成情况，用于核算。<br>·原始凭证分为：自制原始凭证和外来原始凭证</p><p>自制原始凭证：<br>①一次凭证<br>    ▲一次性填制完成；<br>▲只记载一项业务或同时记载若干项同类性质经济业务。<br>②累计凭证<br>    ▲需在规定时间内多次填写才能完成；<br>    ▲分次记载重复发生的经济业务。<br> ③汇总原始凭证<br>▲根据若干同类经济业务的原始凭证定期加以汇总重新编制的凭证。<br>外来原始凭证：<br>一般均属于一次凭证。<br>·记账凭证的含义<br>记账凭证是根据原始凭证进行归类、整理编制的会计分录凭证，是登记账簿的直接依据。</p><p><img src="/pic/06.png" alt="img"><br>根据用途分类：<br> ①专用记账凭证<br>★★★★含义：在每张凭证上只反映一定种类业务内容的记账凭证。（根据不同种类的经济业务内容分别填制记账凭证。）分为收款记账凭证（按照收付实现制，收到商业汇票不算）、付款记账凭证（收付实现制）、转账记账凭证（与货币资金收支无关，如生产产品领用材料）累计折旧要用转账记账凭证<br>★★★借贷双方都涉及货币资金的交易或事项，根据贷方科目填制付款记账凭证，避免重复记账。（比如：提现和存款）★专用记账凭证区分为三种颜色，便于区别和使用<br>②通用记账凭证<br>   ◆含义：可用以反映所有经济业务内容的记账凭证。</p><p>根据会计数目分类：<br>①复式记账凭证<br>    ▲含义：在一张凭证上列示每笔经济业务分录所涉及的全部科目，并均作为记账依据的记账凭证。<br>▲种类：专用记账凭证和通用记账凭证均为复式凭证。<br>②单式记账凭证（很少用）<br>▲含义：按每笔经济业务所涉及科目的数量分别填制凭证的一种记账凭证。<br>★即一笔业务的分录中有几个对应科目，就需要填写几张记账凭证。<br>▲种类：借项记账凭证、贷项记账凭证。</p><p>按记账凭证按包括的业务内容分类：<br> ①单一记账凭证<br>    ●含义：在一张凭证上只包括一笔经济业务内容的记账凭证。<br>●种类：包括专用、通用记账凭证。<br>②汇总记账凭证<br>●含义：根据一定时期内同类单一记账凭证定期加以汇总编制的、在一张凭证上包含若干项经济业务内容的记账凭证。<br>●种类：汇总收款凭证、汇总付款凭证和汇总转账凭证<br>③科目汇总表（记账凭证汇总表）<br>●含义：根据一定时期内的专用（或通用）记账凭证按照相同会计科目定期汇总编制的、包含若干项经济业务的记账凭证。<br>货币资金：银行存款、库存现金。</p><h2 id="第九章-会计账簿（考123节重点是3）"><a href="#第九章-会计账簿（考123节重点是3）" class="headerlink" title="第九章 会计账簿（考123节重点是3）"></a>第九章 会计账簿（考123节重点是3）</h2><h3 id="第一节-账簿的意义与种类"><a href="#第一节-账簿的意义与种类" class="headerlink" title="第一节 账簿的意义与种类"></a>第一节 账簿的意义与种类</h3><p>含义：◆用以全面、连续、系统地记录各项经济业务的簿籍。由具有专门格式、相互联结的账页所组成。（账户开设在账簿之中）<br>作用：1.对凭证资料的系统总结2.考核企业经营情况的重要依据3.会计报表的主要资料来源<br>种类：</p><p>·按照用途分类：<br>1.序时账簿——也称日记账，按照经济业务发生的时间顺序逐日逐笔登记的账簿。（①特种日记账：专门用来登记某一类经济业务的序时账簿。应用较广的是 “现金日记账”和“银行存款日记账”。②普通日记账：用来登记所有经济业务的序时账簿。对所有经济业务都要先在账簿中确定会计分录，予以全面、连续地登记。其内容类似于记账凭证，因此，这种日记账也叫“分录簿”或“分录账”。）一般用特种日记账。<br>2.分类账簿——按照分类会计科目设置的对各项经济业务进行分类登记的账簿。<br>3.备查账簿——也称辅助账簿。是对一些备忘事项为便于查考而登记的账簿。如“租入固定资产登记簿”等。备查账簿不是根据会计科目设置的，与其他账户之间不存在严密的依存关系。<br>租入生产设备（经营性租入）借：制造费用 贷：银行存款</p><p>·会计账簿按外表形式分类<br>①订本式账簿（优点：固定成册并编号，避免账页散失或被抽换。）<br>②活页式账簿（优点：方便灵活，可根据需要增添账页；便于分工记账；便于计算机记账。）<br>③卡片式账簿（优点：耐磨损，便于长期使用；方便灵活，可根据需要增添账页；便于分工记账。）</p><h3 id="第二节-账簿的设置与登记"><a href="#第二节-账簿的设置与登记" class="headerlink" title="第二节 账簿的设置与登记"></a>第二节 账簿的设置与登记</h3><p>第二部分  日记账的格式与登记<br>一、普通日记账的格式与登记方法<br>    1.格式：借、贷两栏式（分录簿）。<br>    2.登记方法：根据原始凭证逐日逐笔登记</p><p>二、特种日记账的格式与登记方法（多用）<br>    1.库存现金日记账<br>    (1)格式：收、付、余(借贷余)三栏式。<br>(2)登记方法：序时逐日逐笔登记。<br>库存现金日记账每日余额计算方法：当日余额&#x3D;前日余额+本日余额-本日付出额<br>2.银行存款日记账<br>（1）格式：收、付、余(借贷余)三栏式。<br>（2）登记方法：序时逐日逐笔登记。<br>★★★现金支票和转账支票对于开出支票的人都用银行存款。</p><p>第三部分   分类账簿的格式与登记（总分类账和明细分类账）<br>（一）总分类账</p><ol><li>格式：借、贷、余三栏式。<br> 2.登记方法<br>  （1）逐笔登记。根据专用（或通用）记账凭证逐笔登记<br>（2）汇总登记。对专用记账凭证进行汇总后，根据汇总数字登记。<br>（二）明细分类账<br>明细分类账格式主要有以下三种：<br>1.借、贷、余三栏式<br>（1）格式：同总分类账<br>（2）登记方法：逐笔登记。<br>★适用范围：往来款项、待摊费用等。<br>★特点：只提供价值指标。<br> 2.数量金额式<br>（1）格式：在借、贷、余三栏中分设数量、单价和金额等栏<br>（2）登记方法：逐笔登记。<br>★适用范围：实物资产业务等。<br>★特点：提供价值、实物量两种指标。<br>3.多栏式<br>（1）按借方、贷方或双方分别设置专栏<br> ①借方多栏式格式<br>★登记方法：逐笔登记。<br>★适用范围：成本、费用等业务。<br>★特点：只提供货币量信息；减少数用红字登记。<br>②贷方多栏式格式<br>★登记方法：逐笔登记。<br>★适用范围：收入等业务。<br>★特点：只提供货币量信息；减少数用红字登记<br>③借方、贷方多栏式格式<br>★登记方法：逐笔登记。<br>★适用范围：应交税费等业务。<br>★特点：只提供货币量信息。</li></ol><h3 id="第三节-账簿的启用与错账更正★★★★★"><a href="#第三节-账簿的启用与错账更正★★★★★" class="headerlink" title="第三节 账簿的启用与错账更正★★★★★"></a>第三节 账簿的启用与错账更正★★★★★</h3><p>第一部分 账簿的启用与登记<br>主要根据记账凭证进行记账。<br>登记要求：<br>1.登记内容齐全<br>2.使用蓝黑墨水，红字限制使用<br>3.账业连续登记，不得空行空页<br>4.记账发生错误，按规定方法更正<br>5.“摘要”简明扼要，书写适当留格<br>6.账页结转处理规范<br>7.注明余额方向<br>8.做好记账标记</p><p>第二部分 错账的更正<br>错的原因：<br>1.填制记账凭证环节出错<br>2.登记账簿环节出错（试算不平衡）<br>查找方法：（前三种为个别检查法）<br>1.差数法：根据确定的双方合计数差额直接查找错账的方法。（漏抄）<br>2.除二法（倍数法）：以双方合计数差额除以2，根据商数查找错账的方法。（借贷抄错）<br>3.除九法：以双方合计数差额除以9，根据商数特征查找错账的方法。（数字抄错）<br>4.顺查（先查凭证再差账簿）&#x2F;逆查</p><p>更正方法：<br>1、未过账，但记账凭证错误：撕掉记账凭证重做<br>2、已过账：（账簿记录）<br>  ①记账凭证正确，登记过账错误（标志词：结算）：划线更正法（用一条红线把错误的数字全部划掉，修改并在旁边签名）<br>  ②记账凭证错误，过账自然一起错<br>   a科目用错、金额写多：红字更正法（先用红字冲销，再用黑字写正确的分录）<br>   b金额写少：补充登记法（直接再做一个分录补充金额），也可用红字更正法（用红字冲销多余的费用）<br>★★★★★改完账之后要加上一句：根据记账凭证登记入账更正错账（这里是有分的！）</p><h2 id="第十章-财产清查（比较重要）"><a href="#第十章-财产清查（比较重要）" class="headerlink" title="第十章   财产清查（比较重要）"></a>第十章   财产清查（比较重要）</h2><h3 id="第一节-财产清查概述"><a href="#第一节-财产清查概述" class="headerlink" title="第一节 财产清查概述"></a>第一节 财产清查概述</h3><p>第一部分  财产清查的意义：<br>1.为会计信息系统的有效运行提供保证。<br>2.为内部控制制度的实施创造有利条件。<br>第二部分  财产清查的种类<br>（范围、时间、执行单位）</p><h3 id="第二节-存货的盘存制度"><a href="#第二节-存货的盘存制度" class="headerlink" title="第二节 存货的盘存制度"></a>第二节 存货的盘存制度</h3><p>第一部分 永续盘存制<br>概念：账面盘存制。是通过设置存货的明细账户，逐笔登记存货的收入数、发出数，并能随时计算出存货结存数量的方法。<br>账簿设置：原材料等，会计部门与仓储部门应常常进行账目核对</p><p>★★★存货成本的计算：<br>1.先进先出法（先入库的尽先卖出，比较繁琐）<br>单价上升时，用先进先出法优于一次加权平均法，账户余额（结存成本）越多说明越好<br>2.加权平均分<br>①一次加权平均法（一个月算一次）总成本&#x2F;总数量（期初＋本期存入）<br>②移动加权平均法（每购入一次就计算一次）（结存+购入&#x2F;结存+购入）<br>3.个别计价法（清楚每一个产品是哪一批的，数量多的不适合）<br>（根据可比性原则，存货成本的计算方法不可随意变更。防止认为调节费用和利润）</p><p>优缺点：<br>1.有利于对数量和金额双重控制<br>2.有利于及时发现存货的不足和短缺<br>3.及时获取存货的积压或不足信息<br>4.明细核算工作量大，需要比较多的人力和财力</p><p>第二部分 实地盘存制（企业对价值较低、损耗较大和难以控制的盘存）<br>概念：在期末时通过盘点实物确定存货的结存数量，并据以确认发出存货数量，借以计算期末结存存货成本和本期发出存货成本的一种盘存方法。通过实地盘点得到期初数量，增加数，期末数，倒推已销存货。<br>计算：（与永续盘存制一样，有三种计价方法。例题：p200）<br>1.期末结存存货成本的计算<br>2.本期发出存货成本的计算</p><p>优缺点：<br>1.核算简单工作量小<br>2.核算不及时，不利于及时获取存货的收发存信息<br>3.手续不严密，不利于监督控制。</p><h3 id="第三节-财产清查的内容和方法"><a href="#第三节-财产清查的内容和方法" class="headerlink" title="第三节  财产清查的内容和方法"></a>第三节  财产清查的内容和方法</h3><p>第一部分  货币资金的清查<br>1.库存现金的清查<br>概念：是将库存现金与库存现金日记账的余额核对，借以确认账实是否相符的方法。利用实地盘存法，每天清查。</p><p><img src="/pic/07.png" alt="img"></p><p>★★★库存现金盘点报告表——重要的原始凭证<br>2.银行存款的清查<br>概念与库存现金清查相同。根据对账单逐笔核对，若余额相符，则一般无错误；若不相符，则可能存在未达账项。</p><p>未达账基本含义：★★★★★<br>企业与银行之间，由于凭证传递时间的不同，而导致记账时间的不一致，对于同一项业务，一方已经接到有关结算凭证并已登记入账，另一方由于没有接到有关结算凭证而尚未登记记账的款项<br>银行存款的余额调节表：<br>银行对账单的余额+银行未收-银行未付&#x3D;银行存款日记账的余额+企业未收-企业未付</p><p><img src="/pic/08.png" alt="img"></p><p>★★★不能作为分录，不能作为原始凭证</p><p>第二部分   实物财产的清查<br>概念：将实物财产账面余额与实物财产实际数核对，以确认账实是否相符的方法。<br>确定方法：<br>实地盘点法(设备、材料等)<br>技术推算法(难以清点存货)<br>抽样盘存法(特质相同存货)<br>函证核对法(委托加工等)<br>制作盘存单，盘存单不为原始凭证。</p><p>第三部分  应收款的清查<br>方法：询证核对法，编制“往来款项对账单”</p><h3 id="第四节-财产清查的结果的处理"><a href="#第四节-财产清查的结果的处理" class="headerlink" title="第四节  财产清查的结果的处理"></a>第四节  财产清查的结果的处理</h3><p>第一部分  处理步骤<br>1.核准金额，查明差异（批准前）<br>2.调整账簿记录，做到账实相符（批准前）<br>3.批准后的转销处理</p><p>第二部分   财产清查的会计处理<br>财产清查结果转销的处理原则：</p><p><img src="/pic/09.png" alt="img"></p><p>分录：（固定资产盘盈1个分录，其他都是两个分录）<br>盘盈：<br>批准前：借：库存现金&#x2F;原材料&#x2F;库存商品···（不包括固定资产）<br>贷：待处理财产损溢<br>批准后：借：待处理财产损溢  贷：营业外收入&#x2F;管理费用&#x2F;····<br>盘亏：<br>批准前：借：待处理财产损溢<br>贷：库存现金&#x2F;原材料&#x2F;库存商品···（不包括固定资产）应交税费<br>批准后：借：营业外收入&#x2F;管理费用&#x2F;其他业务收入（专人负责）&#x2F;····<br>贷：待处理财产损溢——待处理流动资产损溢<br>错题：<br>. 经检查,其他应收款账目有某运输公司欠款 250 元,属于委托该公司运输材料,由于装卸工疏忽而造成的损失。已确定由该公司赔偿,但该运输公司已撤销<br>借：坏账准备 贷：其他应收款<br>★★★正常情况下增值税可以抵扣，但在材料发生了被挪用或盘亏等而未用于产品生产的情况时，则不得抵扣销项税额，该部分进项税额应从原已确认的进项税额中予以减除——进项税额转出。将不可抵扣数记入“应交税费”账户贷方，相当于减少了原记入该账户借方的进项税额（也相当于增加了被抵扣数），实际上交数&#x3D;销项税额-未盘亏的进项税额</p><p>Notice：<br>1.盘盈不可抵税<br>2.盘亏要补税<br>3.不能以盘盈抵减盘亏</p><p>对固定资产的清查：<br>★固定资产盘亏时，其原价和折旧的账面资料应一并进行处理。<br>★固定资产盘盈不经过“待处理财产损溢”账户核算。<br>盘盈时：<br>借：固定资产<br>贷：累计折旧  以前年度损益调整<br>盘亏时：<br>借：待处理财产损溢 累计折旧<br>贷：固定资产<br>借：营业外支出（不可抗力···）&#x2F;其他业务收入（某人负责）&#x2F;管理费用····<br>贷：待处理财产损溢</p><p>对应收款的清查：<br>设置科目：坏账准备（资产类，增加借方减少贷方） 信用减值损失（费用类）<br>“应收账款”账户余额等×提取比例&#x3D;“坏账准备”的余额。<br>分录的数字（属于发生额）&#x3D;坏账准备的余额-之前的余额<br>分录：（3种）<br>坏账准备与信用减值损失一借一贷<br>收回转销的坏账：<br>借：应收账款 贷：坏账准备<br>借：银行存款 贷：应收账款<br>★★★★★发生坏账：（2个分录）<br>借：坏账准备 贷：应收账款   分录的数即为发生额<br>对无法归还的应付款：<br>借：应付账款  贷：营业外收入<br>应收、应付款项等的清查结果，不需要通过“待处理财产损溢”账户核算。<br>固定资产盘盈，不需要通过“待处理财产损溢”账户核算。</p><p>错题：<br>1.丙材料盘盈 25 千克,每千克为 30 元。经查明,其中20千克为代兄弟厂加工剩余材料,该厂未及提回,其余属于日常收发计量差错。<br>借：原材料 150  贷：待处理财产损溢 150<br>借：待处理财产损溢 150 贷：管理费用 150<br>2.经检查,其他应收款账目有某运输公司欠款 250 元,属于委托该公司运输材料,由于装卸工疏忽而造成的损失。已确定由该公司赔偿,但该运输公司已撤销<br>借：坏账准备 250 贷：其他应收款 250<br>第十一章   财务会计报告<br>第一节  财务会计报告概述<br>概念：也称财务报告。是企业对外提供的反映某一特定日期财务状况和某一会计期间经营成果、现金流量等信息的文件。有资产负债表、利润表、现金流量法、所有者权益变动表。附注会介绍很多信息<br>第二节 资产负债表<br>概念：反映企业某一特定日期财务状况的会计报表。<br>资产负债表的编制方法：<br>根据有关规定，企业编制的年度、半年度会计报表至少应反映相接续的两个会计期间的比较数据，即本期“期末数”与“年初数”（上一会计期间期末数）。<br>存货：原材料、生产成本、在途物资、库存商品······<br>应付账款的借方+预付借款的贷方加到应付账款项目<br>应付账款的贷方+预付借款的借方加到预付账款项目</p><h2 id="期末题型：（分值分布）"><a href="#期末题型：（分值分布）" class="headerlink" title="期末题型：（分值分布）"></a>期末题型：（分值分布）</h2><p>单选 15<br>多选10<br>简答题 5<br>计算题 15<br>业务处理题 55</p>]]></content>
    
    
    <categories>
      
      <category>大学学习(大一上)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础会计</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
